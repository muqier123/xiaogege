package com.example.muqier.zhousi.bean;

import java.util.List;

public class BeanList {

    /**
     * success : true
     * data : [{"id":"5c81f8e65b8cb21491ca732b","author_id":"5c1af54c3898674067a76341","tab":"job","content":"<div class=\"markdown-text\"><h2>招聘岗位<\/h2>\n<p><a href=\"https://www.lagou.com/jobs/5545546.html\">Node.js 后台工程师<\/a> 1-3年 12-23K<\/p>\n<p><a href=\"http://https://www.lagou.com/jobs/5545547.html\">高级 Node.js 后台工程师<\/a> 3-5年 25-35K<\/p>\n<p><a href=\"https://www.lagou.com/jobs/5545556.html\">Node.js 后台开发经理<\/a>  5-10年 30-50K<\/p>\n<p><a href=\"https://www.lagou.com/jobs/5545581.html\">Node.js 全栈工程师<\/a> 1-3年 12-23K<\/p>\n<p><a href=\"https://www.lagou.com/jobs/5545582.html\">高级 Node.js 全栈工程师<\/a> 3-5年 25-40K<\/p>\n<h2>福利待遇<\/h2>\n<p>1、当月工资当月发放，2-6 个月的工资作为年终奖\n2、全额工资购买六险一金\n3、带薪病假、带薪年假（入职即可享有 5 天带薪年假）\n4、入职提供最新型号之 Apple 15 \u201d MacBook Pro, LG 真 4K 显示器\n5、办公室零食不间断、每天下午茶\n6、关注员工成长，购买书籍、在线课程均可报销（不限类别）\n7、每年定期体检及其他健康检查\n8、每年不定期外出旅游\n9、任意挑选使用各种付费工具，如 JetBrains IDE, Newrelic, Pingdom, 你想得出，只要可以帮助工作做好，公司绝对愿意支持!<\/p>\n<h2>关于 AfterShip<\/h2>\n<p>网址：<a href=\"https://www.aftership.com/\">https://www.aftership.com/<\/a><\/p>\n<p>2012 年成立于香港，2014 年开始盈利，专注于 SaaS 平台企业服务，业务遍布全球，与全球 470 多家物流公司达成合作，涉及 30 多种主流语言业务体系；帮助跨境电商及平台，将全球快递信息查询自动化，优化发货流程，提高退货效率，减低营运成本，提高买家复购率，让企业专注于品牌建设。<\/p>\n<p>AfterShip 是一家以产品为驱动，技术为核心的公司，日均承担过亿 API 请求。从公司成立开始，便大量使用优秀开源系统，拥抱创新科技，公司有良好的 SaaS 付费习惯，与 Google，Amazon 等公司均有密切的业务来往。<\/p>\n<p>戳这里看看 Google 给我们的介绍 <a href=\"https://cloud.google.com/customers/aftership/\">https://cloud.google.com/customers/aftership/<\/a><\/p>\n<h2>客户案例<\/h2>\n<p>AfterShip 是快递查询行业的全球龙头，客户有 Amazon, Wish, eBay, Paypal, Groupon, Etsy, 及各大小电商超过 100,000 家。<\/p>\n<h2>我们要找的人<\/h2>\n<p>我们是一群热爱编程的代码农,但我们不是代码奴！<\/p>\n<p>我们为写的代码负责，对代码质素有要求，由代码风格开始，测试，编写技术文档，一丝不苟。 我们注重自动化，使用自动化测试，持续集成与持续交付提升生产力。<\/p>\n<p>我们使用 New Relic 作系统监测、Pingdom, Pagerduty 报警、Cloudflare CDN 加速、Twilio 发 SMS、Sendgrid 发邮件、1Password 管理密码、Zoom 视象会议、还有很多很多的工具。<\/p>\n<p>我们为 AfterShip 公司自豪，是因为 AfterShip 对员工的重视，人才永远放在第一，为员工负责， 不断推动我们学习，提升技能。\n我们大量使用开源软件,因为我们深信分享是最伟大的。 我们願意贡献我们有用的,把好的东西跟全世界分享。\n我们使用的 SaaS 工具: <a href=\"https://github.com/AfterShip/SaaS\">https://github.com/AfterShip/SaaS<\/a>\n我们的代码风格: <a href=\"https://github.com/AfterShip/eslint-config-aftership\">https://github.com/AfterShip/eslint-config-aftership<\/a>\n自动格式化全球电话号码: <a href=\"https://github.com/AfterShip/phone\">https://github.com/AfterShip/phone<\/a>\nKoa middleware for New Relic: <a href=\"https://github.com/AfterShip/koa-newrelic\">https://github.com/AfterShip/koa-newrelic<\/a><\/p>\n<p>如果你的想法跟我们一样,欢迎加入我们这支精小而灵活的公司!<\/p>\n<h2>联系方式<\/h2>\n<p>HR 直招，近期和年后看工作的都可以跟我联系哦\n业务增长迅速，持续有需求，欢迎推荐和自荐（推荐他人成功入职，有奖励 1-2W ）\n邮箱： <a href=\"mailto:xhzeng@aftership.com\">xhzeng@aftership.com<\/a>\n微信：z492521906 （备注 cnode、个人姓名、意向岗位）<\/p>\n<\/div>","title":"深圳南山#AfterShip 招聘 Node.js，有高级和leader岗，每天过亿API请求，国际性SaaS平台，全球性项目，福利待遇好","last_reply_at":"2019-03-14T00:20:03.449Z","good":true,"top":false,"reply_count":4,"visit_count":459,"create_at":"2019-03-08T05:08:54.556Z","author":{"loginname":"littleflowersansan","avatar_url":"https://avatars3.githubusercontent.com/u/42596541?v=4&s=120"}},{"id":"5c81c18f5b8cb21491ca70b4","author_id":"53e1802fbd3cc3e50ba9e311","tab":"share","content":"<div class=\"markdown-text\"><p>这几天为 Deno 开发了一个 VS Code 插件：<a href=\"https://marketplace.visualstudio.com/items?itemName=justjavac.vscode-deno\">Deno support for VSCode<\/a>，GitHub 地址：<a href=\"https://github.com/justjavac/vscode-deno\">https://github.com/justjavac/vscode-deno<\/a>。<\/p>\n<p>自 Deno 发布以来就备受关注，也有很多媒体和开发者称 Deno 为\u201c下一代 Node.js\u201d。然而 Deno 的目标则是不兼容 Node.js，没有 npm，没有 package.json。<\/p>\n<p>Deno 的目标旨在提供一个兼容浏览器的平台，因此 Deno 可以像浏览器的 ES Modules 那样，通过 URL 加载模块:<\/p>\n<pre class=\"prettyprint language-js\"><code>import * as log from &quot;https:&#x2F;&#x2F;deno.land&#x2F;x&#x2F;std&#x2F;log&#x2F;mod.ts&quot;;\n<\/code><\/pre><p>而且在加载模块时<strong>不能省略扩展名<\/strong>。<\/p>\n<p>但是，目前的所有开发工具都是为 Node.js 而构建的。在 TypeScript 中，我们不需要添加 <code>.ts<\/code> 扩展名。如果我们添加了，VS Code 会给我们一个错误提示：<\/p>\n<blockquote>\n<p>ts(2691): An import path cannot end with a \u2018.ts\u2019 extension. Consider importing \u2018./hello\u2019 instead.<\/p>\n<\/blockquote>\n<p><img src=\"//static.cnodejs.org/FmViYchU4wYG_7g9TSyHllRUtDzQ\" alt=\"ts-error-2691\"><\/p>\n<p>而另一个问题则是，Deno 可以加载远程模块，但是 TypeScript 却不行。比如上面的代码，也是会报错的：<\/p>\n<blockquote>\n<p>ts(2307): Cannot find module \u2018<a href=\"https://deno.land/x/std/log/mod\">https://deno.land/x/std/log/mod<\/a>\u2019.<\/p>\n<\/blockquote>\n<p><img src=\"//static.cnodejs.org/FsbcG1h3loRuD1WHlZuudPuiG4-I\" alt=\"ts-error-2307\"><\/p>\n<p>而这个插件正是为了解决这 2 个问题。<\/p>\n<p>但是这两个错误不是 VS Code 提供了，而是 TypeScript 的编译器 tsc 提供的，因此需要修改 tsc 的功能。好消息是，TypeScript 从 2.3 开始便支持了 <a href=\"https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin\">Language Service Plugin<\/a>，这个功能仅能增强编辑体验，无法改变 TypeScript 核心行为（比如改变类型检查行为）或增加新特性（比如提供一种新语法或者）。通过查看 Language Service Plugin 的说明文件，这个功能正是我需要的。<\/p>\n<p>所以在写这个 VS Code 插件之前，我又为 TypeScript 写了一个插件：<a href=\"https://github.com/justjavac/typescript-deno-plugin\">typescript-deno-plugin<\/a>。这个插件不仅可以用在 VS Code，还可以用在任何支持 TypeScript 的编辑器，比如 Atom、Visual Studio、WebStorm 等。<\/p>\n<p>VS Code 插件提供了开箱即用的 Deno 支持，开发者不需要任何配置，但是有一个前提是：开发者需要使用 VS Code 内置的 TypeScript。如果你在项目中自行安装了 TypeScript，并且修改了 VS Code 的配置，使用了自己安装的版本，则需要自行安装配置 <a href=\"https://github.com/justjavac/typescript-deno-plugin\">typescript-deno-plugin<\/a> 插件。通过修改 <code>tsconfig.json<\/code> 的 <code>plugins<\/code>：<\/p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;compilerOptions&quot;: {\n    &quot;plugins&quot;: [\n      {\n        &quot;name&quot;: &quot;typescript-deno-plugin&quot;\n      }\n    ]\n  }\n}\n<\/code><\/pre><p>如果你正在打算学习 Deno 的开发，可以通过这个链接 <a href=\"https://marketplace.visualstudio.com/items?itemName=justjavac.vscode-deno\">Deno support for VSCode<\/a> 安装插件。<\/p>\n<p>祝，开发愉快。<\/p>\n<\/div>","title":"我为 Deno 开发了一个 VS Code 插件","last_reply_at":"2019-03-13T04:04:58.544Z","good":true,"top":false,"reply_count":6,"visit_count":715,"create_at":"2019-03-08T01:12:47.402Z","author":{"loginname":"justjavac","avatar_url":"https://avatars1.githubusercontent.com/u/359395?v=4&s=120"}},{"id":"5c3700673898674067a7da2c","author_id":"4efc278625fa69ac6900038f","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://img.alicdn.com/tfs/TB1AruuBjTpK1RjSZKPXXa3UpXa-1890-566.png\" alt=\"main\"><\/p>\n<p>双旦已过，新年将至，midwayJs 向大家献上贺礼，首先奉上地址: <a href=\"https://github.com/midwayjs/midway/\">https://github.com/midwayjs/midway/<\/a>，欢迎 star ✨✨✨。<\/p>\n<p>之前我们向社区开放了我们的治理工具，也就是 Pandora.js 工具包，用于整个 Node.js 应用的监控和治理，我们承诺这不是结束，只是开源的开始。<\/p>\n<p>随着内部全栈应用数的越来越多，以及阿里业务不断提升的复杂度，比如店铺，搭建以及渲染等服务，随着人员的不断调动，产品的结构，代码的层级都随着不断的调整，我们急需一个能降低代码复杂度的解决方案，帮助我们渡过人员寒冬，这就对我们内部的基础架构体系提出了不同的要求。<\/p>\n<p>以往我们只需要让用户启动服务器，满足 RPC/HTTP 服务即可，而在真正的全栈领域，似乎没有太多的钻研和沉淀。对此，我们将内部使用的 midway 整体解决方案进行了一次重塑，并且在设计之初就提出未来将对外进行开源。<\/p>\n<p>正巧我们的第一款 Typescript 产品 Pandora.js 开源完毕，给了我们将代码用 Typescript 重写的信心，也随着 Egg.js 社区的壮大，我们相信，在不同的领域中，一定会有不同的产品，不同的解决方案。<\/p>\n<p>Midway 正式基于这些考虑，将 IoC 引入到了框架中，同时学习了 NestJs ，引入了不少自定义的装饰器，增强开发体验，也将搭配团队的其他产品，Pandora.js 和 Sandbox，将 Node.js 的开发体验朝着全新的场景发展，让用户在开发过程中享受到前所未有的愉悦感。<\/p>\n<p>在这里感谢前期的 beta 测试中向我们提意见以及试用的同学，感谢大家的包容和支持，特别是 <a href=\"/user/ZQun\">@ZQun<\/a> 和 <a href=\"/user/yuu2lee4\">@yuu2lee4<\/a> 两位的积极参与。<\/p>\n<p><img src=\"https://img.alicdn.com/tfs/TB19dSLBXzqK1RjSZFvXXcB7VXa-771-85.png\" alt=\"image-20190109121917392\"><\/p>\n<p>下面来介绍新版本 midway 的一些特性。<\/p>\n<ul>\n<li>\n<p>基于 IoC 体系业务代码进行解耦，依赖统一管理统一初始化<\/p>\n<\/li>\n<li>\n<p>常见的 web 场景装饰器简化业务开发<\/p>\n<\/li>\n<li>\n<p>支持 Egg.js 的所有插件体系，框架装饰器统一编码风格<\/p>\n<\/li>\n<li>\n<p>基于 Typescript ，面向接口编程的编码体验<\/p>\n<\/li>\n<\/ul>\n<h2>依赖注入疑问<\/h2>\n<p>在一年前，我们的业务代码是重重耦合，到处初始化，实例重复，但这并不是业务同学在代码架构方面的问题，而是在不断的业务迭代，交接下，早就脱离了最初的设想，代码的设计跟不上需求的速度。<\/p>\n<p>为此，我们尝试引入了依赖注入的方案。依赖注入最早听到是在 Java 端的 spring 框架，在 JS 方面，最早我们使用了 XML 做为基础的 IoC 方案，虽然解决了不少耦合和初始化的问题，也发现前端在 XML 的感受吐槽颇多。<\/p>\n<p>去年 Typescript 的大力发展之后，内部的很多项目都切换了过来，经过我们的调研，除了 NestJs 进行了自研以及在 Typescript 领域比较出名的 Inversify 模块，似乎很少有现成的易于扩展的模块。<\/p>\n<p>基于这些情况，我们进行了这方面的自建，一方面方便内部的扩展，能更好的在现有的体系上扩展装饰器，请求作用域等，另一方面也可以提升本身的能力，方便后续迭代。<\/p>\n<p>我们产出了 <code>injection<\/code> 模块，作为我们整个框架的依赖注入基础。<\/p>\n<p>如今，<code>injection<\/code> 承载起了整个 midway 体系，它将框架代码，业务代码，插件等都组合到了一起，像一个纽带在这些之间传输数据。<\/p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1AQmDBgDqK1RjSZSyXXaxEVXa-2730-556.png\" alt=\"dep_image\"><\/p>\n<p>通过依赖注入容器的管理，如上图非常复杂的应用也能良好的维护和运作。<\/p>\n<p>想看完整大图，可以点击<a href=\"https://img.alicdn.com/tfs/TB1Ha5JBgHqK1RjSZFgXXa7JXXa-5328-556.png\">这里<\/a>。<\/p>\n<h2>面向装饰器开发<\/h2>\n<p>得益于 Typescript 对 ES6 的良好支持，提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器作为TypeScript的实验性功能能够让我们在开发中简化代码。虽然是语法糖，但是带来的好处却不少。<\/p>\n<p>我们拿一个简单的例子，从 Controller 一步步经过 Service/Manager 向数据库拿数据，在多层的架构体系下，以往的代码大概率需要 new 出不同的实例，并且需要绑定到路由层，这边为了方便理解，代码放到了一起。<\/p>\n<pre class=\"prettyprint language-typescript\"><code>export = (app) =&gt; {\n  const home = new HomeController();\n  app.get(&#x27;&#x2F;&#x27;, home.index);\n}\n\nclass HomeController extends Controller {\n\n  reportService: IReportService;\n\n  constructor() {\n    this.reportService = new ReportService();\n  }\n    \n  async index(ctx) {\n    ctx.body = await this.reportService.getReport();\n  }\n}\n\nclass ReportService implements IReportService {\n\n  reporter: IReportManager;\n  \n  constructor() {\n    this.reporter = new ReporterManager();\n  }\n\n\n  async getReport(id: number) {\n    return await this.reporter.get(id);\n  }\n}\n\nclass ReporterManager implements IReportManager {\n\n  db;\n\n  constructor() {\n    this.initDB();\n  }\n\n  initDB() {\n    &#x2F;&#x2F; open connection\n  }\n\n  async get() {\n    &#x2F;&#x2F; return data from db;\n  }\n}\n\n<\/code><\/pre><p>经过 IoC 相关的 <code>@provide<\/code> 和 <code>@inject<\/code>  装饰器修饰以及其他 web 层的装饰器修饰过后，不仅仅只是代码量的减少，业务的代码也不再有实例化的过程。以往还需要考虑在构造器中做异步的操作，比如初始化时需要做异步连接数据库，这个时候也不再需要考虑，直接使用 <code>@init<\/code> 装饰即可。<\/p>\n<p>至此，我们会更加专注于面向接口进行编程，抽象，将代码设计的时间更多的花在理解需求，解决问题上。<\/p>\n<pre class=\"prettyprint language-typescript\"><code>@provide()\n@controller()\nexport class HomeController {\n\n  @inject()\n  reportService: IReportService;\n  \n  @get(&#x27;&#x2F;&#x27;)\n  async index(ctx) {\n    ctx.body = await this.reportService.getReport();\n  }\n}\n\n@provide()\nclass ReportService implements IReportService {\n\n  @inject()\n  reporter: IReportManager;\n  \n  async getReport(id: number) {\n    return await this.reporter.get(id);\n  }\n}\n\n@provide()\nclass ReporterManager implements IReportManager {\n\n  @inject()\n  db;\n\n  @init()\n  initDB() {\n    &#x2F;&#x2F; open connection\n  }\n\n  async get() {\n    &#x2F;&#x2F; return data from db;\n  }\n}\n<\/code><\/pre><h2>入口能力<\/h2>\n<p>就像上面提到的 <code>@controller<\/code> 装饰器类似，针对入口型的代码，我们在框架层面扩展了其他装饰器，比如针对计划任务形式我们提供了 <code>@schedule<\/code> 装饰器，简化用户开发的代码量。<\/p>\n<pre class=\"prettyprint language-typescript\"><code>import { schedule } from &#x27;midway&#x27;;\n\n@schedule({\n  interval: 2333, &#x2F;&#x2F; 2.333s 间隔\n  type: &#x27;worker&#x27;, &#x2F;&#x2F; 指定某一个 worker 执行\n})\n\nexport class HelloCron {\n  &#x2F;&#x2F; 定时执行的具体任务\n  async exec(ctx) {\n    ctx.logger.info(process.pid, &#x27;hello&#x27;);\n  }\n}\n<\/code><\/pre><p>在下一版本中，我们将开放自定义装饰器的能力，方便更多场景的使用。<\/p>\n<h2>框架扩展<\/h2>\n<p>由于在大多数场景下，使用了装饰器已经依赖注入的写法，使得自己的业务代码，乃至三方的模块都能很好的融在一起，除了这些之外，有的同学会疑问，原本的插件，配置，上下文部分如何融入到这个体系，我们这就来解答。<\/p>\n<p>在原本熟悉的体系中，只要有 <code>app<\/code> , <code>ctx<\/code> 对象就无敌了，所有的东西都可以拿。而在 midway 中，为了和 web 层进行解耦，我们隐去了这些对象，只希望业务代码和 IoC 容器打交道。<\/p>\n<p>为此我们提供了 <code>@config<\/code> 和 <code>@plugin<\/code> 装饰器用于获取不同的方法，通过这样的形式和框架进行解耦，比如在任意代码中如下使用。<\/p>\n<pre class=\"prettyprint language-typescript\"><code>@provide()\nclass ReportService implements IReportService {\n\n  @config(&#x27;env&#x27;)\n  env;\n\n  @plugin(&#x27;httpclient&#x27;)\n  httpclient;\n\n  @inject()\n  reporter: IReportManager;\n  \n  async getReport(id: number) {\n    const rid = this.httpclient.request(&#x27;&#x2F;api&#x2F;&#x27; + id);\n    return await this.reporter.get(rid);\n  }\n}\n<\/code><\/pre><p>正是这样一点点的调整，我们将整个应用的代码风格保持了到了一致，不管代码几经易手，维护的同学也能快速上手，并且继续迭代下去。<\/p>\n<h2>最后<\/h2>\n<p>正向我们在 Pandora.js 发布时说的那样，midway 也是 MidwayJs 团队长期维护的一款产品，同样不会是最后一款，前几个月，我们就计划将我们的监控平台 Sandbox 带出来回馈给社区，虽然道阻且长，任务艰辛，我们依旧在努力前行，欢迎关注。<\/p>\n<p>最后，<a href=\"http://link.zhihu.com/?target=https%3A//github.com/midwayjs/pandora/\">midway<\/a> 的地址在这 <a href=\"http://link.zhihu.com/?target=https%3A//github.com/midwayjs/midway/\">https://github.com/midwayjs/midway/<\/a>，归属在 midwayJs Group 下。欢迎走过路过点个 Star，给我们提提建议，提提代码。<\/p>\n<p>Midway 官网：<a href=\"https://midwayjs.org/midway/\">https://midwayjs.org/midway/<\/a><\/p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1TQ9.BhjaK1RjSZKzXXXVwXXa-1448-541.png\" alt=\"image-20190110141919113\"><\/p>\n<\/div>","title":"midway v1.0 社区正式发布 - 面向未来的全栈开发方案","last_reply_at":"2019-03-13T01:16:10.602Z","good":true,"top":false,"reply_count":62,"visit_count":3765,"create_at":"2019-01-10T08:20:55.350Z","author":{"loginname":"czy88840616","avatar_url":"//gravatar.com/avatar/c4e414b7264b513a00bbd8ec3e9a0d66?s=48"}},{"id":"5b63b25e792f59ae501bf71c","author_id":"59c12213e7d9a031127ead16","tab":"share","content":"<div class=\"markdown-text\"><h4>RPC是什么<\/h4>\n<p>在很久之前的单机时代，一台电脑中跑着多个进程，进程之间没有交流各干各的，就这样过了很多年。突然有一天有了新需求，A进程需要实现一个画图的功能，恰好邻居B进程已经有了这个功能，偷懒的程序员C想出了一个办法：A进程调B进程的画图功能。于是出现了<code>IPC<\/code>（Inter-process communication，进程间通信）。就这样程序员C愉快的去吃早餐去了！<\/p>\n<p>又过了几年，到了互联网时代，每个电脑都实现了互联互通。这时候雇主又有了新需求，当时还没挂的A进程需要实现使用<code>tensorflow<\/code>识别出笑脸 &gt;_&lt; 。说巧不巧，远在几千里的一台快速运行的电脑上已经实现了这个功能，睡眼惺忪的程序媛D接手了这个A进程后借鉴之前<code>IPC<\/code>的实现，把<code>IPC<\/code>扩展到了互联网上，这就是<code>RPC<\/code>(Remote Procedure Call，远程过程调用)。<code>RPC<\/code>其实就是一台电脑上的进程调用另外一台电脑上的进程的工具。成熟的<code>RPC<\/code>方案大多数会具备服务注册、服务发现、熔断降级和限流等机制。目前市面上的RPC已经有很多成熟的了，比如<code>Facebook<\/code>家的<code>Thrift<\/code>、<code>Google<\/code>家的<code>gRPC<\/code>、阿里家的<code>Dubbo<\/code>和蚂蚁家的<code>SOFA<\/code>。<\/p>\n<h4>接口定义语言<\/h4>\n<p>接口定义语言，简称<code>IDL,<\/code>是实现端对端之间可靠通讯的一套编码方案。这里有涉及到传输数据的序列化和反序列化，我们常用的http的请求一般用json当做序列化工具，定制<code>rpc<\/code>协议的时候因为要求响应迅速等特点，所以大多数会定义一套序列化协议。比如：<\/p>\n<p><code>Protobuf<\/code>：<\/p>\n<pre class=\"prettyprint language- protobuf\"><code>&#x2F;&#x2F; protobuf 版本\nsyntax = &quot;proto3&quot;;\n \npackage testPackage;\n \nservice testService {\n  &#x2F;&#x2F; 定义一个ping方法，请求参数集合pingRequest, 响应参数集合pingReply \n  rpc ping (pingRequest) returns (pingReply) {}\n}\n \nmessage pingRequest {\n  &#x2F;&#x2F; string 是类型，param是参数名，1是指参数在方法的第1个位置\n  string param = 1;\n}\n \nmessage pingReply {\n  string message = 1;\n  string content = 2;\n}\n<\/code><\/pre><p>讲到<code>Protobuf<\/code>就得讲到该库作者的另一个作品<code>Cap'n proto<\/code>了，号称性能是直接秒杀<code>Google Protobuf<\/code>，直接上官方对比：<\/p>\n<p><img src=\"https://capnproto.org/images/infinity-times-faster.png\" alt=\"Cap'n proto\"><\/p>\n<p>虽然知道很多比<code>Protobuf<\/code>更快的编码方案，但是快到这种地步也是厉害了，为啥这么快，Cap\u2019n Proto的文档里面就立刻说明了，因为<code>Cap'n Proto<\/code>没有任何序列号和反序列化步骤，<code>Cap'n Proto<\/code>编码的数据格式跟在内存里面的布局是一致的，所以可以直接将编码好的structure直接字节存放到硬盘上面。贴个栗子：<\/p>\n<pre class=\"prettyprint language- shell\"><code>@0xdbb9ad1f14bf0b36;  # unique file ID, generated by &#96;capnp id&#96;\n\nstruct Person {\n  name @0 :Text;\n  birthdate @3 :Date;\n\n  email @1 :Text;\n  phones @2 :List(PhoneNumber);\n\n  struct PhoneNumber {\n    number @0 :Text;\n    type @1 :Type;\n\n    enum Type {\n      mobile @0;\n      home @1;\n      work @2;\n    }\n  }\n}\n\nstruct Date {\n  year @0 :Int16;\n  month @1 :UInt8;\n  day @2 :UInt8;\n}\n<\/code><\/pre><p>我们这里要定制的编码方案就是基于<code>protobuf<\/code>和<code>Cap'n Proto<\/code>结合的类似的语法。因为本人比较喜欢刀剑神域里的男主角，所以就给这个库起了个名字    \u2014\u2014 <code>Kiritobuf<\/code>。<\/p>\n<p>首先我们定义<code>kirito<\/code>的语法：<\/p>\n<pre class=\"prettyprint language-bash\"><code># test\n\nservice testService {\n  method ping (reqMsg, resMsg)\n}\n\nstruct reqMsg {\n  @0 age = Int16;\n  @1 name = Text;\n}\n\nstruct resMsg {\n  @0 age = Int16;\n  @1 name = Text;\n}\n<\/code><\/pre><ul>\n<li><code>#<\/code> 开头的是注释<\/li>\n<li>保留关键字, <code>service<\/code>、<code>method<\/code>、<code>struct<\/code>,<\/li>\n<li><code>{}<\/code>里是一个块结构<\/li>\n<li><code>()<\/code>里有两个参数，第一个是请求的参数结构，第二个是返回值的结构<\/li>\n<li><code>@<\/code>是定义参数位置的描述符，<code>0<\/code>表示在首位<\/li>\n<li><code>=<\/code>号左边是参数名，右边是参数类型<\/li>\n<\/ul>\n<p>参数类型：<\/p>\n<ul>\n<li><strong>Boolean:<\/strong> <code>Bool<\/code><\/li>\n<li><strong>Integers:<\/strong> <code>Int8<\/code>, <code>Int16<\/code>, <code>Int32<\/code>, <code>Int64<\/code><\/li>\n<li><strong>Unsigned integers:<\/strong> <code>UInt8<\/code>, <code>UInt16<\/code>, <code>UInt32<\/code>, <code>UInt64<\/code><\/li>\n<li><strong>Floating-point:<\/strong> <code>Float32<\/code>, <code>Float64<\/code><\/li>\n<li><strong>Blobs:<\/strong> <code>Text<\/code>, <code>Data<\/code><\/li>\n<li><strong>Lists:<\/strong> <code>List(T)<\/code><\/li>\n<\/ul>\n<p>定义好了语法和参数类型，我们先过一下生成有抽象关系代码的流程：<\/p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/kirito.jpg\" alt=\"ast\"><\/p>\n<p>取到<code>.kirito<\/code>后缀的文件，读取全部字符，通过词法分析器生成<code>token<\/code>，得到的<code>token<\/code>传入语法分析器生成<code>AST (抽象语法树)<\/code>。<\/p>\n<p>首先我们新建一个<code>kirito.js<\/code>文件:<\/p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27;;\n\nconst fs = require(&#x27;fs&#x27;);\nconst tokenizer = Symbol.for(&#x27;kirito#tokenizer&#x27;);\nconst parser = Symbol.for(&#x27;kirito#parser&#x27;);\nconst transformer = Symbol.for(&#x27;kirito#transformer&#x27;);\n&#x2F;&#x2F; 定义词法分析Token类型 \nconst TYPE = {\n  &#x2F;&#x2F; 保留字，service、struct、method...\n  KEYWORD: &#x27;keyword&#x27;,\n  &#x2F;&#x2F; 变量\n  VARIABLE: &#x27;variable&#x27;,\n  &#x2F;&#x2F; 符号，{ } ( ) ; # @ ,\n  SYMBOL: &#x27;symbol&#x27;,\n  &#x2F;&#x2F; 参数位置，数值表示0、1、2、3...\n  INDEX: &#x27;index&#x27;\n};\n&#x2F;&#x2F; 定义语法分析字段类型\nconst EXP = {\n  &#x2F;&#x2F; 变量\n  VARIABLE: &#x27;Identifier&#x27;,\n  &#x2F;&#x2F; 结构申明，service、struct、method\n  STRUCT_DECLARATIONL: &#x27;StructDeclaration&#x27;,\n  &#x2F;&#x2F; 变量申明，@\n  VAR_DECLARATION: &#x27;VariableDeclaration&#x27;,\n  &#x2F;&#x2F; 数据类型, Int16、UInt16、Bool、Text...\n  TYPE: &#x27;DataType&#x27;,\n};\n<\/code><\/pre><p>定义好了一些必要的字面量，接下来首先是词法分析阶段。<\/p>\n<h5>词法解析<\/h5>\n<p>我们设计词法分析得到的<code>Token<\/code>是这样子的：<\/p>\n<pre class=\"prettyprint language-shell\"><code>[ { type: &#x27;keyword&#x27;, value: &#x27;service&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;testService&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;method&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;ping&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;(&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;reqMsg&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;resMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;)&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;struct&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;reqMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;1&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;age&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Int16&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;2&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;name&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Text&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; },\n  { type: &#x27;keyword&#x27;, value: &#x27;struct&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;resMsg&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;{&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;1&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;age&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Int16&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;@&#x27; },\n  { type: &#x27;index&#x27;, value: &#x27;2&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;name&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;=&#x27; },\n  { type: &#x27;variable&#x27;, value: &#x27;Text&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;;&#x27; },\n  { type: &#x27;symbol&#x27;, value: &#x27;}&#x27; } ]\n<\/code><\/pre><p>词法分析步骤：<\/p>\n<ul>\n<li>把获取到的<code>kirito<\/code>代码串按照<code>\\n<\/code>分割组合成数组A，数组的每个元素就是一行代码<\/li>\n<li>遍历数组A，将每行代码逐个字符去读取<\/li>\n<li>在读取的过程中定义匹配规则，比如注释、保留字、变量、符号、数组等<\/li>\n<li>将每个匹配的字符或字符串按照对应类型添加到tokens数组中<\/li>\n<\/ul>\n<p>代码如下：<\/p>\n<pre class=\"prettyprint language-javascript\"><code>[tokenizer] (input) {\n    &#x2F;&#x2F; 保留关键字\n    const KEYWORD = [&#x27;service&#x27;, &#x27;struct&#x27;, &#x27;method&#x27;];\n    &#x2F;&#x2F; 符号\n    const SYMBOL = [&#x27;{&#x27;, &#x27;}&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;=&#x27;, &#x27;@&#x27;, &#x27;;&#x27;];\n    &#x2F;&#x2F; 匹配所有空字符\n    const WHITESPACE = &#x2F;\\s&#x2F;;\n    &#x2F;&#x2F; 匹配所有a-z的字符、不限大小写\n    const LETTERS = &#x2F;^[a-z]$&#x2F;i;\n    &#x2F;&#x2F; 匹配数值\n    const NUMBER = &#x2F;\\d&#x2F;;\n    \n    &#x2F;&#x2F; 以换行符分割成数组\n    const source = input.split(&#x27;\\n&#x27;);\n    &#x2F;&#x2F; 最终生成的token数组\n    const tokens = [];\n    source.some(line =&gt; {\n      &#x2F;&#x2F; 声明一个 &#96;current&#96; 变量作为指针\n      let current = 0;\n      &#x2F;&#x2F; 是否继续当前循环、移动到下一行，用于忽略注释\n      let isContinue = false;\n      while (current &lt; line.length) {\n        let char = line[current];\n\n        &#x2F;&#x2F; 匹配任何空字符\n        if (WHITESPACE.test(char)) {\n          current++;\n          continue;\n        }\n\n        &#x2F;&#x2F; 忽略注释\n        if (char === &#x27;#&#x27;) {\n          isContinue = true;\n          break;\n        }\n\n        &#x2F;&#x2F; 匹配a-z|A-Z的字符\n        if (LETTERS.test(char)) {\n          &#x2F;&#x2F; 定义一个字符串变量，用来存储连续匹配成功的字符\n          let value = &#x27;&#x27;;\n          &#x2F;&#x2F; 匹配字符(变量&#x2F;保留字)、字符加数字(参数类型)\n          while (LETTERS.test(char) || NUMBER.test(char)) {\n            &#x2F;&#x2F; 追加字符\n            value += char;\n            &#x2F;&#x2F; 移动指针\n            char = line[++current];\n          }\n          if (KEYWORD.indexOf(value) !== -1) {\n            &#x2F;&#x2F; 匹配保留关键字\n            tokens.push({\n              type: TYPE.KEYWORD,\n              value: value\n            });\n          } else {\n            &#x2F;&#x2F; 匹配变量名、类型\n            tokens.push({\n              type: TYPE.VARIABLE,\n              value: value\n            });\n          }\n          continue;\n        }\n\n        &#x2F;&#x2F; 匹配符号 { } ( ) = @\n        if (SYMBOL.indexOf(char) !== -1) {\n          tokens.push({\n            type: TYPE.SYMBOL,\n            value: char\n          });\n          &#x2F;&#x2F; 匹配@ 参数位置符号\n          if (char === &#x27;@&#x27;) {\n            char = line[++current];\n            &#x2F;&#x2F; 匹配参数位置0-9\n            if (NUMBER.test(char)) {\n              &#x2F;&#x2F; 定义参数位置字符串，用来存储连续匹配成功的参数位置\n              let index = &#x27;&#x27;;\n              &#x2F;&#x2F; 匹配参数位置0-9\n              while (NUMBER.test(char)) {\n                &#x2F;&#x2F; 追加参数位置 &#96;1&#96;+&#96;2&#96;=&#96;12&#96;\n                index += char;\n                char = line[++current];\n              }\n              tokens.push({\n                type: TYPE.INDEX,\n                value: index\n              });\n            }\n            continue;\n          }\n          current++;\n          continue;\n        }\n        current++;\n      }\n        \n      &#x2F;&#x2F; 跳过注释\n      if (isContinue) return false;\n    });\n    return tokens;\n  }\n<\/code><\/pre><h5>语法分析<\/h5>\n<p>得到上面的词法分析的token后，我们就可以对该token做语法分析，我们需要最终生成的AST的格式如下：<\/p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;type&quot;: &quot;Program&quot;,\n  &quot;body&quot;: [\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;service&quot;,\n      &quot;value&quot;: &quot;testService&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;StructDeclaration&quot;,\n          &quot;name&quot;: &quot;method&quot;,\n          &quot;value&quot;: &quot;ping&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;reqMsg&quot;\n            },\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;resMsg&quot;\n            }\n          ]\n        }\n      ]\n    },\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;struct&quot;,\n      &quot;value&quot;: &quot;reqMsg&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;1&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;age&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Int16&quot;\n            }\n          ]\n        },\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;2&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;name&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Text&quot;\n            }\n          ]\n        }\n      ]\n    },\n    {\n      &quot;type&quot;: &quot;StructDeclaration&quot;,\n      &quot;name&quot;: &quot;struct&quot;,\n      &quot;value&quot;: &quot;resMsg&quot;,\n      &quot;params&quot;: [\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;1&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;age&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Int16&quot;\n            }\n          ]\n        },\n        {\n          &quot;type&quot;: &quot;VariableDeclaration&quot;,\n          &quot;name&quot;: &quot;@&quot;,\n          &quot;value&quot;: &quot;2&quot;,\n          &quot;params&quot;: [\n            {\n              &quot;type&quot;: &quot;Identifier&quot;,\n              &quot;value&quot;: &quot;name&quot;\n            },\n            {\n              &quot;type&quot;: &quot;DataType&quot;,\n              &quot;value&quot;: &quot;Text&quot;\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n<\/code><\/pre><p>看上图我们能友好的得到结构、参数、数据类型、函数之间的依赖和关系，步骤：<\/p>\n<ul>\n<li>遍历词法分析得到的token数组，通过调用分析函数提取token之间的依赖节点<\/li>\n<li>分析函数内部定义token提取规则，比如：\n<ol>\n<li>服务保留字  服务名  { 函数保留字 函数名 ( 入参，返回参数 ) }<\/li>\n<li>参数结构保留字 结构名 { 参数位置 参数名 参数数据类型 }<\/li>\n<\/ol>\n<\/li>\n<li>递归调用分析函数提取对应节点依赖关系，将节点添加到AST中<\/li>\n<\/ul>\n<p>代码如下：<\/p>\n<pre class=\"prettyprint language-js\"><code>[parser] (tokens) {\n    &#x2F;&#x2F; 声明ast对象，作为分析过程中的节点存储器\n    const ast = {\n      type: &#x27;Program&#x27;,\n      body: []\n    };\n    &#x2F;&#x2F; 定义token数组指针变量\n    let current = 0;\n    \n    &#x2F;&#x2F; 定义函数、用例递归分析节点之间的依赖和存储\n    function walk() {\n      &#x2F;&#x2F; 当前指针位置的token节点\n      let token = tokens[current];\n\n      &#x2F;&#x2F; 检查变量、数据类型\n      if (token.type === TYPE.VARIABLE) {\n        current++;\n        return {\n          type: EXP.VARIABLE,\n          struct: tokens[current].value === &#x27;=&#x27; ? false : true,\n          value: token.value\n        };\n      }\n\n      &#x2F;&#x2F; 检查符号\n      if (token.type === TYPE.SYMBOL) {\n        &#x2F;&#x2F; 检查@，添加参数位置绑定\n        if (token.value === &#x27;@&#x27;) {\n          &#x2F;&#x2F; 移动到下一个token, 通常是个数值，也就是参数位置\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义参数节点，用来存储位置、变量名、数据类型\n          let node = {\n            type: EXP.VAR_DECLARATION,\n            name: &#x27;@&#x27;,\n            value: token.value,\n            params: []\n          };\n            \n          &#x2F;&#x2F; 移动到下一个token, 准备开始读取参数变量名和数据类型\n          token = tokens[++current];\n          &#x2F;&#x2F; 每个参数节点以;符号结束\n          &#x2F;&#x2F; 这个循环中会匹配参数变量名和参数数据类型并把他们添加到当前的参数节点上\n          while (token.value !== &#x27;;&#x27;) {\n            &#x2F;&#x2F; 递归匹配参数变量名、数据类型\n            node.params.push(walk());\n            &#x2F;&#x2F; 指定当前指针的token\n            token = tokens[current];\n          }\n          &#x2F;&#x2F; 移动token数组指针\n          current++;\n          &#x2F;&#x2F; 返回参数节点\n          return node;\n        }\n\n        &#x2F;&#x2F; 检查=，匹配该符号右边的参数数据类型\n        if (token.value === &#x27;=&#x27;) {\n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          current++;\n          return {\n            type: EXP.TYPE,\n            value: token.value\n          };\n        }\n\n        current++;\n      }\n\n      &#x2F;&#x2F; 检查保留字\n      if (token.type === TYPE.KEYWORD) {\n        &#x2F;&#x2F; 检查service、struct\n        if ([&#x27;struct&#x27;, &#x27;service&#x27;].indexOf(token.value) !== -1) {\n          &#x2F;&#x2F; 缓存保留字\n          let keywordName = token.value;\n          &#x2F;&#x2F; 移动到下一个token，通常是结构名\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义结构节点，用来储存结构保留字、结构名、结构参数数组\n          let node = {\n            type: EXP.STRUCT_DECLARATIONL,\n            &#x2F;&#x2F; 保留字\n            name: keywordName,\n            &#x2F;&#x2F; 结构名\n            value: token.value,\n            &#x2F;&#x2F; 参数数组\n            params: []\n          };\n\n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          &#x2F;&#x2F; 匹配符号且是{,准备解析{里的参数\n          if (token.type === TYPE.SYMBOL &amp;&amp; token.value === &#x27;{&#x27;) {\n            &#x2F;&#x2F; 移动到下一个token\n            token = tokens[++current];\n            &#x2F;&#x2F; 等于}是退出参数匹配，完成参数储存\n            while (token.value !== &#x27;}&#x27;) {\n              &#x2F;&#x2F; 递归调用分析函数，获取参数数组\n              node.params.push(walk());\n              &#x2F;&#x2F; 移动token到当前指针\n              token = tokens[current];\n            }\n            current++;\n          }\n          &#x2F;&#x2F; 返回结构节点\n          return node;\n        }\n\n        if (token.value === &#x27;method&#x27;) {\n          &#x2F;&#x2F; 检查method，匹配请求函数名\n          token = tokens[++current];\n          &#x2F;&#x2F; 定义请求函数节点，用来储存函数入参和返回参数\n          let node = {\n            type: EXP.STRUCT_DECLARATIONL,\n            name: &#x27;method&#x27;,\n            value: token.value,\n            params: []\n          };\n            \n          &#x2F;&#x2F; 移动到下一个token\n          token = tokens[++current];\n          &#x2F;&#x2F; 匹配(符号,准备储存入参和返回参数\n          if (token.type === TYPE.SYMBOL &amp;&amp; token.value === &#x27;(&#x27;) {\n            &#x2F;&#x2F; 移动到入参token\n            token = tokens[++current];\n            &#x2F;&#x2F; 等于)时退出匹配，完成函数匹配\n            while (token.value !== &#x27;)&#x27;) {\n              &#x2F;&#x2F; 递归调用分析函数\n              node.params.push(walk());\n              token = tokens[current];\n            }\n            current++;\n          }\n          &#x2F;&#x2F; 返回函数节点\n          return node;\n\n        }\n      }\n      \n      &#x2F;&#x2F; 抛出未匹配到的错误\n      throw new TypeError(token.type);\n    }\n\n    &#x2F;&#x2F; 遍历token数组\n    while (current &lt; tokens.length) {\n      ast.body.push(walk());\n    }\n    \n    &#x2F;&#x2F; 返回ast\n    return ast;\n  }\n<\/code><\/pre><h5>转换器<\/h5>\n<p>得到了语法分析的<code>AST<\/code>后我们需要进一步对<code>AST<\/code>转换为更易操作的<code>js对象<\/code>。格式如下：<\/p>\n<pre class=\"prettyprint language-javascript\"><code>{ \n    testService: { \n        ping: {\n            [Function]\n            param: { \n                reqMsg: { \n                    age: &#x27;Int16&#x27;, \n                    name: &#x27;Text&#x27; \n                },\n                resMsg: { \n                    age: &#x27;Int16&#x27;, \n                    name: &#x27;Text&#x27; \n                } \n            }\n        } \n    } \n}\n<\/code><\/pre><p>通过上面这个格式，我们可以更容易的知道有几个<code>service<\/code>、<code>service<\/code>里有多少个函数以及函数的参数。<\/p>\n<p>代码如下：<\/p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 转换器\n  [transformer] (ast) {\n    &#x2F;&#x2F; 定义汇总的service\n    const services = {};\n    &#x2F;&#x2F; 定义汇总的struct，用来储存参数结构，以便最后和service合并\n    const structs = {};\n\n    &#x2F;&#x2F; 转换数组\n    function traverseArray(array, parent) {\n      &#x2F;&#x2F; 遍历数组\n      array.some((child) =&gt; {\n        &#x2F;&#x2F; 分治转换单个节点\n        traverseNode(child, parent);\n      });\n    }\n\n    function traverseNode (node, parent) {\n\n      switch (node.type) {\n      case &#x27;Program&#x27;:\n        &#x2F;&#x2F; 根节点\n        traverseArray(node.body, parent);\n        break;\n      case &#x27;StructDeclaration&#x27;:\n        &#x2F;&#x2F; 匹配service、struct、method类型节点\n        if (node.name === &#x27;service&#x27;) {\n          &#x2F;&#x2F; 定义service的父节点为对象，为了更好的添加属性\n          parent[node.value] = {};\n          &#x2F;&#x2F; 调用数组转换函数解析，并把父节点传入以便添加子节点\n          traverseArray(node.params, parent[node.value]);\n        } else if (node.name === &#x27;method&#x27;) {\n          &#x2F;&#x2F; 定义一个空函数给method节点\n          parent[node.value] = function () {};\n          &#x2F;&#x2F; 在该函数下挂载一个param属性作为函数的参数列表\n          parent[node.value].param = {};\n          traverseArray(node.params, parent[node.value].param);\n        } else if (node.name === &#x27;struct&#x27;) {\n          &#x2F;&#x2F; 定义struct的父节点为一个对象\n          structs[node.value] = {};\n          &#x2F;&#x2F; 解析struct\n          traverseArray(node.params, structs[node.value]);\n        }\n        break;\n      case &#x27;Identifier&#x27;:\n        &#x2F;&#x2F; 定义参数变量\n        parent[node.value] = {};\n        break;\n      case &#x27;VariableDeclaration&#x27;:\n        &#x2F;&#x2F; 解析参数数组\n        traverseArray(node.params, parent);\n        break;\n      case &#x27;DataType&#x27;:\n        &#x2F;&#x2F; 参数数据类型\n        parent[Object.keys(parent).pop()] = node.value;\n        break;\n      default:\n        &#x2F;&#x2F; 抛出未匹配到的错误\n        throw new TypeError(node.type);\n      }\n    }\n\n    traverseNode(ast, services);\n      \n    &#x2F;&#x2F; 合并service和struct\n    const serviceKeys = Object.getOwnPropertyNames(services);\n    serviceKeys.some(service =&gt; {\n      const methodKeys = Object.getOwnPropertyNames(services[service]);\n      methodKeys.some(method =&gt; {\n        Object.keys(services[service][method].param).some(p =&gt; {\n          if (structs[p] !== null) {\n            services[service][method].param[p] = structs[p];\n            delete structs[p];\n          }\n        });\n      });\n    });\n\n    return services;\n  }\n<\/code><\/pre><h4>传输协议<\/h4>\n<p><code>RPC<\/code>协议有多种，可以是<code>json、xml、http2<\/code>，相对于http1.x这种文本协议，http2.0这种二进制协议更适合作为<code>RPC<\/code>的应用层通信协议。很多成熟的<code>RPC<\/code>框架一般都会定制自己的协议已满足各种变化莫测的需求。<\/p>\n<p>比如<code>Thrift<\/code>的<code>TBinaryProtocol<\/code>、<code>TCompactProtocol<\/code>等，用户可以自主选择适合自己的传输协议。<\/p>\n<p>大多数计算机都是以字节编址的（除了按字节编址还有按字编址和按位编址），我们这里只讨论字节编址。每个机器因为不同的系统或者不同的CPU对内存地址的编码有不一样的规则，一般分为两种字节序：大端序和小端序。<\/p>\n<blockquote>\n<p>大端序: 数据的高字节保存在低地址<\/p>\n<\/blockquote>\n<blockquote>\n<p>小端序: 数据的低字节保存在高地址<\/p>\n<\/blockquote>\n<p>举个栗子：<\/p>\n<p>比如一个整数：<code>258<\/code>，用16进制表示为<code>0x0102<\/code>，我们把它分为两个字节<code>0x01<\/code>和<code>ox02<\/code>，对应的二进制为<code>0000 0001<\/code>和<code>0000 0010<\/code>。在大端序的电脑上存放形式如下：<\/p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/big.jpg\" alt=\"big\"><\/p>\n<p>小端序则相反。为了保证在不同机器之间传输的数据是一样的，开发一个通讯协议时会首先约定好使用一种作为通讯方案。<code>java虚拟机<\/code>采用的是大端序。在机器上我们称为<code>主机字节序<\/code>，网络传输时我们称为<code>网络字节序<\/code>。网络字节序是<code>TCP/IP<\/code>中规定好的一种数据表示格式，它与具体的<code>CPU<\/code>类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节序采用大端排序方式。<\/p>\n<p>我们这里就不造新应用层协议的轮子了，我们直接使用<code>MQTT<\/code>协议作为我们的默认应用层协议。<code>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议）<\/code>，是一种基于<code>发布/订阅<\/code>（<code>publish/subscribe<\/code>）模式的\u201c轻量级\u201d通讯协议，采用大端序的网络字节序传输，该协议构建于<code>TCP/IP<\/code>协议上。<\/p>\n<h4>实现通讯<\/h4>\n<p>先贴下实现完的代码调用流程，首先是server端：<\/p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst pRPC = require(&#x27;..&#x27;);\nconst path = require(&#x27;path&#x27;);\nconst kiritoProto = &#x27;.&#x2F;protocol&#x2F;test.kirito&#x27;;\nconst server = new pRPC.Server();\n&#x2F;&#x2F; 解析kirito文件生成js对象\nconst proto = pRPC.load(path.join(__dirname, kiritoProto));\n\n&#x2F;&#x2F; 定义client端可以调用的函数\nfunction test(call, cb) {\n  cb(null, {age: call.age, name: call.name});\n}\n\n&#x2F;&#x2F; 加载kirito解析出来的对象和函数绑定，这里声明了ping的执行函数test\nserver.addKiritoService(proto.testService, {ping: test});\n\nserver.listen(10003);\n<\/code><\/pre><p>client端：<\/p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst pRPC = require(&#x27;..&#x27;);\nconst path = require(&#x27;path&#x27;);\nconst kiritoProto = &#x27;.&#x2F;protocol&#x2F;test.kirito&#x27;;\n&#x2F;&#x2F; 解析kirito文件生成js对象\nconst proto = pRPC.load(path.join(__dirname, kiritoProto));\n&#x2F;&#x2F; 分配一个client实例绑定kirito解析的对象并连接server\nconst client =  new pRPC.Client({host: &#x27;localhost&#x27;, port: 10003}, proto.testService);\n\n&#x2F;&#x2F; 调用server端的函数\nclient.ping({age: 23, name: &#x27;ricky 泽阳&#x27;}, function (err, result) {\n  if (err) {\n    throw new Error(err.message);\n  }\n  console.log(result);\n});\n<\/code><\/pre><p>无论是server端定义函数或者client端调用函数都是比较简洁的步骤。接下来我们慢慢剖析具体的逻辑实现。<\/p>\n<p>贴下具体的调用流程架构图：<\/p>\n<p><img src=\"https://raw.githubusercontent.com/rickyes/rickyes.github.io/master/image/mqt_rpc.jpg\" alt=\"rpc\"><\/p>\n<p>调用流程总结：<\/p>\n<ul>\n<li>client端解析kirito文件，绑定kirito的service到client对象<\/li>\n<li>server端解析kirito文件，将kiritod的service与调用函数绑定添加到server对象<\/li>\n<li>client端调用kirito service 里定义的函数，注册回调事件，发起MQTT请求<\/li>\n<li>server端接收MQTT请求，解析请求body，调用对应的函数执行完后向client端发起MQTT请求<\/li>\n<li>client端接收到MQTT请求后，解析body和error，并从回调事件队列里取出对应的回调函数并赋值执行<\/li>\n<\/ul>\n<p>说完了调用流程，现在开始讲解具体的实现。<\/p>\n<blockquote>\n<p><strong>server<\/strong>：<\/p>\n<\/blockquote>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol&#x2F;mqtt.js\n\n&#x27;use strict&#x27;;\n\nconst net = require(&#x27;net&#x27;);\nconst debug = require(&#x27;debug&#x27;)(&#x27;polix-rpc:mqtt&#x27;);\nconst EventEmitter = require(&#x27;events&#x27;).EventEmitter;\nconst mqttCon = require(&#x27;mqtt-connection&#x27;);\n\n&#x2F;&#x2F; 定义server类，继承EventEmitter是为了更好的将模块解耦\nclass MQTT extends EventEmitter {\n\n  constructor () {\n    super();\n    &#x2F;&#x2F; 是否已经开启服务\n    this.inited = false;\n    &#x2F;&#x2F; 函数集合\n    this.events = {};\n  }\n\n  &#x2F;&#x2F; 监听端口并开启服务\n  listen (port, cb) {\n    &#x2F;&#x2F; 已经初始化了就不用再次init\n    if (this.inited) {\n      cb &amp;&amp; cb(new Error(&#x27;already inited.&#x27;, null));\n      return;\n    }\n    &#x2F;&#x2F; 赋值当前作用域上下文的指针给self对象，用来在非当前作用的函数执行当前作用域的代码\n    const self = this;\n    &#x2F;&#x2F; 设置初始化\n    this.inited = true;\n    &#x2F;&#x2F; 实例化一个net服务\n    this.server = new net.Server();\n    this.port = port || 10003;\n    &#x2F;&#x2F; 监听端口\n    this.server.listen(this.port);\n    debug(&#x27;MQTT Server is started for port: %d&#x27;, this.port);\n      \n    &#x2F;&#x2F; 监听error事件\n    this.server.on(&#x27;error&#x27;, (err) =&gt; {\n      debug(&#x27;rpc server is error: %j&#x27;, err.stack);\n      self.emit(&#x27;error&#x27;, err);\n    });\n      \n    &#x2F;&#x2F; 监听连接事件\n    this.server.on(&#x27;connection&#x27;, (stream) =&gt; {\n      &#x2F;&#x2F; 实例化mqtt对象\n      const socket = mqttCon(stream);\n      debug(&#x27;=========== new connection ===========&#x27;);\n      \n      &#x2F;&#x2F; 监听mqtt服务connect事件\n      socket.on(&#x27;connect&#x27;, () =&gt; {\n        debug(&#x27;connected&#x27;);\n        socket.connack({ returnCode: 0 });\n      });\n\n      socket.on(&#x27;error&#x27;, (err) =&gt; {\n        debug(&#x27;error : %j&#x27;, err);\n        socket.destroy();\n      });\n\n      socket.on(&#x27;close&#x27;, () =&gt; {\n        debug(&#x27;===========     close     ============&#x27;);\n        socket.destroy();\n      });\n\n\n      socket.on(&#x27;disconnect&#x27;, () =&gt; {\n        debug(&#x27;===========   disconnect   ============&#x27;);\n        socket.destroy();\n      });\n        \n      &#x2F;&#x2F; 监听mqtt服务publish事件，接收client端请求\n      socket.on(&#x27;publish&#x27;, (pkg) =&gt; {\n        &#x2F;&#x2F; 消费client端的请求\n        self.consumers(pkg, socket);\n      });\n    });\n  }\n    \n  &#x2F;&#x2F; 消费client端的请求\n  consumers (pkg, socket) {\n    &#x2F;&#x2F; 赋值当前作用的指针给self对象\n    const self = this;\n    &#x2F;&#x2F; 将client的数据包转成json字符，字节序不同的处理已经在mqtt的底层转换好了\n    let content = pkg.payload.toString();\n    debug(content);\n    content = JSON.parse(content);\n    &#x2F;&#x2F; 定义响应数据包\n    const respMsg = {\n      msgId: content.msgId\n    };\n    &#x2F;&#x2F; 如果请求调用的函数不存在则加上错误消息响应回去client端\n    if (this.events[content.method] === null) {\n      &#x2F;&#x2F; 定义调用错误消息\n      respMsg.error = {\n        message: &#96;not found ${content.method} method&#96;\n      };\n      &#x2F;&#x2F; 推送到client端\n      self.response(socket, {messageId: pkg.messageId, body: respMsg});\n    } else {\n      &#x2F;&#x2F; 如果存在有效的函数则准备调用\n      const fn = this.events[content.method].method;\n      &#x2F;&#x2F; 设置调用函数的回调事件，用来处理调用函数完成后的参数返回\n      const callback = function (err, result) {\n        &#x2F;&#x2F; 获取调用完后的参数结果\n        respMsg.body = result;\n        &#x2F;&#x2F; 推送到client端\n        self.response(socket, {messageId: pkg.messageId, body: respMsg});\n      };\n      &#x2F;&#x2F; 执行调用参数\n      fn.call(fn, content.body, callback);\n    }\n  }\n    \n  &#x2F;&#x2F; 推送调用结果数据包给client端\n  response (socket, result) {\n    socket.publish({\n      topic: &#x27;rpc&#x27;,\n      qos: 1,\n      messageId: result.messageId,\n      payload: JSON.stringify(result.body)\n    });\n  }\n\n\n  &#x2F;&#x2F; 绑定kirito定义的函数集合\n  addEvent (events) {\n    const eventKeys = Object.getOwnPropertyNames(events);\n    eventKeys.some(event =&gt; {\n      this.events[event] = {\n        method: events[event].method,\n        param: events[event].param\n      };\n    });\n  }\n\n}\n\nmodule.exports.create = function () {\n  return new MQTT();\n};\n<\/code><\/pre><p>定义protocol接口，加上这一层是为了以后的多协议，mqtt只是默认使用的协议：<\/p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol.js\n\n&#x27;use strict&#x27;;\n\nconst mqtt = require(&#x27;.&#x2F;protocol&#x2F;mqtt&#x27;);\n\nmodule.exports.create = function (opts = {}) {\n  return mqtt.create(opts);\n};\n<\/code><\/pre><p>接下来是server端的暴露出去的接口：<\/p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; index.js\n\n&#x27;use strict&#x27;;\n\nconst protocol = require(&#x27;.&#x2F;protocol.js&#x27;);\n\nclass Server {\n\n  constructor () {\n    &#x2F;&#x2F; 实例化协议对象\n    this.server = protocol.create();\n  }\n    \n  &#x2F;&#x2F; 将kirito定义的接口和函数集合绑定\n  addKiritoService (service, methods) {\n    const serviceKeys = Object.getOwnPropertyNames(service);\n    const methodKeys = Object.getOwnPropertyNames(methods);\n    const events = {};\n    serviceKeys.some(method =&gt; {\n      let idx = -1;\n      if ((idx = methodKeys.indexOf(method)) !== -1) {\n        events[method] = {\n          method: methods[method],\n          param: service[method].param\n        };\n        methodKeys.splice(idx, 1);\n      }\n    });\n    if (Object.keys(events).length &gt; 0) {\n      this.server.addEvent(events);\n    }\n  }\n\n  listen (port) {\n    this.server.listen(port);\n  }\n\n}\n\nmodule.exports = Server;\n<\/code><\/pre><blockquote>\n<p><strong>client<\/strong>：<\/p>\n<\/blockquote>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol&#x2F;mqtt.js\n\n&#x27;use strict&#x27;;\n\nconst net = require(&#x27;net&#x27;);\nconst debug = require(&#x27;debug&#x27;)(&#x27;polix-rpc:mqtt&#x27;);\nconst EventEmitter = require(&#x27;events&#x27;).EventEmitter;\nconst mqttCon = require(&#x27;mqtt-connection&#x27;);\n\nclass MQTT extends EventEmitter {\n\n  constructor (server) {\n    super();\n    &#x2F;&#x2F; 获取server端连接信息\n    this.host = server.host || &#x27;localhost&#x27;;\n    this.port = server.port || 10003;\n    &#x2F;&#x2F; 是否服务已连接\n    this.connected = false;\n    &#x2F;&#x2F; 是否服务已关闭\n    this.closed = false;\n  }\n    \n  &#x2F;&#x2F; 连接server服务\n  connect (cb) {\n    &#x2F;&#x2F; 连接了就不用再次执行连接\n    if (this.connected) {\n      cb &amp;&amp; cb (new Error(&#x27;mqtt rpc has already connected&#x27;), null);\n      return;\n    }\n\n    &#x2F;&#x2F; 复制当前作用域上下文的指针给self变量\n    const self = this;\n    &#x2F;&#x2F; 获取net服务连接流\n    const stream = net.createConnection(this.port, this.host);\n    &#x2F;&#x2F; 初始化mqtt服务\n    this.socket = mqttCon(stream);\n    &#x2F;&#x2F; 监听conack事件\n    this.socket.on(&#x27;connack&#x27;, (pkg) =&gt; {\n      debug(&#x27;conack: %j&#x27;, pkg);\n    });\n\n    &#x2F;&#x2F; 监听error事件\n    this.socket.on(&#x27;error&#x27;, function (err) {\n      debug(&#x27;error: %j&#x27;, err);\n    });\n\n\n    &#x2F;&#x2F; 监听publish事件，接收server端调用函数结果的返回数据\n    this.socket.on(&#x27;publish&#x27;, (pkg) =&gt; {\n      &#x2F;&#x2F; 将数据包转成json字符\n      const content = pkg.payload.toString();\n      debug(content);\n      &#x2F;&#x2F; 将数据转发到MQTT的对象事件上\n      this.emit(&#x27;data&#x27;, JSON.parse(content));\n    });\n\n    &#x2F;&#x2F; 监听puback事件\n    this.socket.on(&#x27;puback&#x27;, (pkg) =&gt; {\n      debug(&#x27;puback: %j&#x27;, pkg);\n    });\n\n    &#x2F;&#x2F; 发起连接\n    this.socket.connect({\n      clientId: &#x27;MQTT_RPC_&#x27; + Math.round(new Date().getTime() &#x2F; 1000)\n    }, () =&gt; {\n      if (self.connected) {\n        return;\n      }\n        \n      &#x2F;&#x2F; 设置已连接\n      self.connected = true;\n\n      cb &amp;&amp; cb(null, {connected: self.connected});\n    });\n  }\n    \n  &#x2F;&#x2F; 发起调用函数请求\n  send (param) {\n    this.socket.publish({\n      topic: &#x27;rpc&#x27;,\n      qos: 1,\n      messageId: 1,\n      payload: JSON.stringify(param || {})\n    });\n  }\n\n  &#x2F;&#x2F; 关闭连接\n  close () {\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    this.connected = false;\n    this.socket.destroy();\n  }\n\n}\n\nmodule.exports.create = function (server) {\n  return new MQTT(server || {});\n};\n<\/code><\/pre><p>定义protocol接口：<\/p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; protocol.js\n\n&#x27;use strict&#x27;;\n\nconst mqtt = require(&#x27;.&#x2F;protocol&#x2F;mqtt&#x27;);\n\nmodule.exports.create = function (opts = {}) {\n  return mqtt.create(opts);\n};\n<\/code><\/pre><p>最后是client端暴露的接口：<\/p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst protocol = require(&#x27;.&#x2F;protocol.js&#x27;);\nconst connect = Symbol.for(&#x27;connect&#x27;);\nconst uuid = require(&#x27;uuid&#x2F;v1&#x27;);\n\nclass Client {\n\n  constructor(opts, service) {\n    &#x2F;&#x2F; 声明client实例\n    this.client = void(0);\n    &#x2F;&#x2F; 调用协议连接接口\n    this[connect](opts, service);\n    &#x2F;&#x2F; 定义回调参数集合\n    this.callQueues = {};\n  }\n\n  &#x2F;&#x2F; 连接server\n  [connect] (opts, service) {\n    &#x2F;&#x2F; 初始化协议服务\n    this.client = protocol.create(opts);\n    &#x2F;&#x2F; 发起连接\n    this.client.connect((err) =&gt; {\n      if (err) {\n        throw new Error(err);\n      }\n    });\n      \n    &#x2F;&#x2F; 复制当前作用域的上下文指针给self对象\n    const self = this;\n\n    &#x2F;&#x2F; 监听协议data时间，接收协议转发server端响应的数据\n    this.client.on(&#x27;data&#x27;, function (result) {\n      &#x2F;&#x2F; 听过msgId取出回调函数\n      const fn = self.callQueues[result.msgId];\n      &#x2F;&#x2F; 如果有调用错误信息，则直接回调错误\n      if (result.error) {\n        return fn.call(fn, result.error, null);\n      }\n      &#x2F;&#x2F; 执行回调\n      fn.call(fn, null, result.body);\n    });\n    &#x2F;&#x2F; 绑定kirito定义的接口参数到协议对象中\n    const serviceKeys = Object.getOwnPropertyNames(service);\n    serviceKeys.some(method =&gt; {\n      &#x2F;&#x2F; 增加client端的函数，对应server端的调用函数\n      self[method] = function () {\n        &#x2F;&#x2F; 取出发送的数据\n        const reqMsg = arguments[0];\n        &#x2F;&#x2F; 取出回调函数\n        const fn = arguments[1];\n        const paramKey = Object.getOwnPropertyNames(service[method].param);\n        paramKey.some((param) =&gt; {\n          if (reqMsg[param] === null) {\n            throw new Error(&#96;Parameters &#x27;${param}&#x27; are missing&#96;);\n          }\n          &#x2F;&#x2F; todo 类型判断及转换\n        });\n        &#x2F;&#x2F; 为每个请求标记\n        const msgId = uuid();\n        &#x2F;&#x2F; 注册该请求的回调函数到回调队列中\n        self.callQueues[msgId] = fn;\n        &#x2F;&#x2F; 发起调用函数请求\n        self.client.send({method, msgId, body: reqMsg});\n      };\n    });\n  }\n\n}\n\nmodule.exports = Client;\n<\/code><\/pre><p>就这样，一个简单的IDL+RPC框架就这样搭建完成了。这里只是描述RPC的原理和常用的调用方式，要想用在企业级的开发上，还得加上服务发现、注册，服务熔断，服务降级等，读者如果有兴趣可以在Github上fork下来或者提PR来改进这个框架，有什么问题也可以提Issue, 当然PR是最好的 : ) 。<\/p>\n<p>仓库地址：<\/p>\n<p>RPC: <a href=\"https://github.com/polixjs/polix-rpc\">https://github.com/polixjs/polix-rpc<\/a><\/p>\n<p>IDL: <a href=\"https://github.com/rickyes/kiritobuf\">https://github.com/rickyes/kiritobuf<\/a><\/p>\n<\/div>","title":"从零开始实现一个IDL+RPC框架","last_reply_at":"2019-03-12T06:49:22.140Z","good":true,"top":false,"reply_count":30,"visit_count":4213,"create_at":"2018-08-03T01:39:42.660Z","author":{"loginname":"zhoumingque","avatar_url":"https://avatars3.githubusercontent.com/u/20432815?v=4&s=120"}},{"id":"5a328967d92f2f5b185ace96","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><p>本来不想回复的，匿名的那哥们写的挺好的，虽然不懂他为什么要匿名。但看到某些回复，不得不说几句。乱解读，误人子弟的事，还是有必要澄清的，以免Node有无端被黑，相信这也是所有布道者都应该承担这种除魔卫道的责任。<\/p>\n<blockquote>\n<p>没有领袖，Node 之父用 Go，TJ 也用 Go，都跑了。<\/p>\n<\/blockquote>\n<ol>\n<li>语言不是因素，是他想做的事儿变了，但他的心依然还是爱着Koa<\/li>\n<\/ol>\n<p>TJ转做Go有很多原因<\/p>\n<ul>\n<li>人家做的基于aws Lambda的基础设施 <a href=\"https://github.com/apex/apex%EF%BC%8C%E9%80%89%E6%8B%A9Go%E6%97%A0%E5%8F%AF%E5%8E%9A%E9%9D%9E%EF%BC%8C%E4%BB%8E%E6%9E%B6%E6%9E%84%E8%A7%92%E5%BA%A6%EF%BC%8C%E6%88%91%E8%BF%98%E8%A6%81%E7%BB%99%E4%BB%96%E7%82%B9%E8%B5%9E%EF%BC%81\">https://github.com/apex/apex，选择Go无可厚非，从架构角度，我还要给他点赞！<\/a><\/li>\n<li>TJ对Node.js一直很关注，尤其对Koa框架，看他的Pinned repositories 就知道，另外给Koa提issue被他怼过，也可见他很在意Koa<\/li>\n<\/ul>\n<p>别乱解读，误人子弟<\/p>\n<ol>\n<li>Node.js之父在2012年就离开社区的，然而这5年发展的依然很好<\/li>\n<\/ol>\n<p>狼叔写过一篇文章 <a href=\"https://cnodejs.org/topic/59daf46f2543cb3368b1627e\">请别拿\u201c死\u201d人做文章<\/a>，\nNode.js之父Ryan Dahl在2012年就离开社区的，我们必须要承认他作为创始人的伟大创举，但不能标签化，ryan不代表node，从他离开社区后，对于社区而言，他就\u201c死\u201d在曾经的丰功伟绩上，未来与他无关！<\/p>\n<p>Node.js之父在2012年就离开社区的，然而这5年发展的依然很好，并无影响。这篇文章本来没什么问题，但有些人借位营销就恶心了。<\/p>\n<p>狼叔说：Node.js不是最好，也不是最差，是性价比比较高的，可惜node做后端一直不温不火，java，php利益相关，只有新项目用，微服务架构下，会更好一些。很多人node是用错的，不是用node就什么都用，分清场景。不误解，不传谣，合适自己的才是最好的\n但是总有些人想拿这事儿做文章过度解读，<\/p>\n<blockquote>\n<p>抽象程度不够高，对于做业务的人来说这很痛苦。使用者中小白太多，人员素质参差不齐，包的数量多，质量却呵呵。<\/p>\n<\/blockquote>\n<p>这完全是没逻辑的屁话，看起来没问题，却经不起推敲。<\/p>\n<p>抽象程度，所有语言都有这个问题，Go就没有么？Java、PHP这么多年小白少么？说人员素质参差不齐，哪个语言不一样？所以说，这完全是狗屁逻辑。我比较喜欢Ruby社区，是高手和低手两级分化最明显。Node.js从2009年到现在才8年，再成熟能成熟到哪里呢？不拿一个起点比较都是扯淡。<\/p>\n<p>最后说npm，黑的完全不到点上，目前超过60万个模块，绝对是社区第一。在众多包管理器上，我没见过质量都一样好的，按照8020原则，60万里至少有12万个模块是不错的吧，你工作中能用到的会超过三位数么？<\/p>\n<p>所以说质量好不好要看人怎么选，而不应该赖到npm上。长点心吧。<\/p>\n<blockquote>\n<p>用来做脚本倒是没啥问题，做商业开发就处处踩坑了。我没怎么用 Node做 Web，因为怕 hold 不住。<\/p>\n<\/blockquote>\n<p>没用过，就别瞎逼逼。<\/p>\n<p>国内国外的成功案例，眼瞎看不到么？我亲历的去哪儿和阿里都在大量使用，我亲耳听到的腾讯大量使用Node，对于李成银所在的360团队也是大量使用。<\/p>\n<p>如果说 Node hold 不住，其他语言就能 hold 住？呵呵<\/p>\n<p>如果说 人 hold 不住，那我相信，那是水平问题。<\/p>\n<blockquote>\n<p>目前 Node Web 框架依然是 koa 和 express 类似的架构，中间件没什么问题，但是如何组织它们，如何在 high level 层面把控他们却没有看到很好的最佳实践。<\/p>\n<\/blockquote>\n<p>没用Node还哔哔框架，不是打脸么？<\/p>\n<p>我们可以根据框架的特性进行分类<\/p>\n<table>\n<thead>\n<tr>\n<th>框架名称<\/th>\n<th>特性<\/th>\n<th>点评<\/th>\n<\/tr>\n<\/thead>\n<tbody>\n<tr>\n<td>Express<\/td>\n<td>简单、实用，路由中间件等五脏俱全<\/td>\n<td>最著名的Web框架<\/td>\n<\/tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor<\/td>\n<td>同构<\/td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高<\/td>\n<\/tr>\n<tr>\n<td>Sails、Total<\/td>\n<td>面向其他语言，Ruby、PHP等<\/td>\n<td>借鉴业界优秀实现，也是 Node.js 成熟的一个标志<\/td>\n<\/tr>\n<tr>\n<td>MEAN.js<\/td>\n<td>面向架构<\/td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点<\/td>\n<\/tr>\n<tr>\n<td>Hapi和Restfy<\/td>\n<td>面向Api &amp;&amp; 微服务<\/td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器<\/td>\n<\/tr>\n<tr>\n<td>ThinkJS<\/td>\n<td>面向新特性<\/td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右，新版v3.0是基于Koa v2.0的作为内核的<\/td>\n<\/tr>\n<tr>\n<td>Koa<\/td>\n<td>专注于异步流程改进<\/td>\n<td>下一代Web框架<\/td>\n<\/tr>\n<tr>\n<td>Egg<\/td>\n<td>基于Koa，在开发上有极大便利<\/td>\n<td>企业级Web开发框架<\/td>\n<\/tr>\n<\/tbody>\n<\/table>\n<p>各种框架都经过大厂小厂实践，别的语言实现的我敢说Node都有了。还有什么所谓的更好实践，从2005年rails横空出世之后，大部分框架都是借鉴ROR，Node就算没有走到最前面，至少没有落后于最佳实践，否则，请给出，否则，请闭嘴，别瞎逼逼。<\/p>\n<blockquote>\n<p>大公司也是相继开发自己基于 koa 的框架。<\/p>\n<\/blockquote>\n<p>悖论，去哪儿的基于Express用的杠杠的，无任何问题。Node不缺Web框架，Koa虽好，但迁移各种还需要时间，未来是变化的，Koa能否一统天下还犹未可知。可以肯定的是Koa在异步流程控制做的改进，命名为Node下一个Web框架是不过分的。<\/p>\n<p>比如micro，比如fastify，非常多好东西。<\/p>\n<blockquote>\n<p>不过在我一个 Rails 使用者的眼里，这些框架还是不够 high level如果性能要求高，我的选择肯定是 Go 而不是 Node。<\/p>\n<\/blockquote>\n<p>用rails的人还考虑性能么？我不是黑ror的朋友们。rails这样的神器足够好，即使ruby以前性能那么不好，但不影响人家开发很多世界级应用啊。尽管后面有的被替换了，但又怎样呢？做ror的高手技能都非常全面，ruby和前端和运维都是极其的熟练。当然Node和go也有这样的人，但普遍偏弱，这不是人的问题，而是产生的时间较短，没背景的人就不能出现全栈牛逼的能力。<\/p>\n<p>如果真追求性能，我建议用rust写，如果还想牛逼，用c写，最好顺便把操作系统也写了。<\/p>\n<p>人还是要有自知之明，做应用软件和系统软件是不一样的思维。傻逼才只看性能呢。<\/p>\n<blockquote>\n<p>Node 除了亲 JS 好像对我没啥吸引力。但是如果公司非要用我也不反对，大不了自己摸爬滚打找出最佳实践即可。<\/p>\n<\/blockquote>\n<p>没用过，请绕过。我特别尊重苏千和朴灵，推动Node在阿里落地，比如苏千做的cnpm真是功德无量，比如Egg，能够统一全公司的资源去推动框架落地，可预见大公司阻力。朴灵的alinode解决了性能调优的问题，内部使用的经验沉淀，对外提供付费服务。<\/p>\n<p>这是人物。做的比说的多，低调如此，也不去惹是非。用德艺双馨形容不为过。<\/p>\n<blockquote>\n<p>Node 还有一个好处是 UI 做的好，比如 pm2，比如调试器，毕竟是前端，但这些都不是杀手级的卖点呀。我不是挑语言的开发者。<\/p>\n<\/blockquote>\n<p>Node 和 UI有关系么？呵呵呵<\/p>\n<blockquote>\n<p>Node 对我属于一个可用可不用位置。不过相信牛逼的你肯定可以玩转 Node。加油吧少年。我对Node新人的建议是玩一玩可以，<\/p>\n<\/blockquote>\n<p>没用过，就别瞎逼逼。<\/p>\n<p>js已经横跨3端，pc/h5，移动端（hybrid和组件化），pc client（nw.js和electron，atom和vscode体验还不错）<\/p>\n<p>Node补足了js服务端的补足，比如io，比如过于依赖浏览器。<\/p>\n<ul>\n<li>1）初衷，server端，不想成了前端开发的基础设施<\/li>\n<li>2）命令行辅助工具，甚至可以是运维<\/li>\n<li>3）移动端：cordova，pc端：nw.js和electron<\/li>\n<li>4）组件化，构建，代理<\/li>\n<li>5）架构，前后端分离、api proxy<\/li>\n<li>6）性能优化、反爬虫与爬虫<\/li>\n<li>\n<ol>\n<li>全栈最便捷之路<\/li>\n<\/ol>\n<\/li>\n<\/ul>\n<blockquote>\n<p>不过要早点转 Go，因为 Node 并没有什么突出的优势。<\/p>\n<\/blockquote>\n<p>Go在服务器端，并发模型上确实很好。做后端是极好的选型。但在前后端分离或者单体应用里，真的合适么？<\/p>\n<p>前面说了，性能并不是继续选型的唯一因素，不然ror那些牛人早转了。我一直的看法是前端离不开node，api层node有优势，io密集和脚本动态，做api组装聚合类的非常合适。对于后端服务，Node也是可以的，不过这时的node和go是一样的，尤其是上了微服务架构，服务是独立的，和语言无关，按照其特性选就好了，何必扯一些没用的。<\/p>\n<p>最后说一下Node全栈<\/p>\n<p>每次演讲我会都问大家是不是前端，回答\u201c是\u201d的人非常多，我会开玩笑的恭喜大家：\u201c现在的前端就是钱端\u201d，确实，现在前端发展异常的快，而且没有趋向于类比java里ssh框架的那种稳定，所以未来很长一段时间，还会增长，持续混乱，这对前端来说是把双刃剑，一方面有很强的压迫感，不学习就跟不上时代，另一方它也是机遇，能够带给更多机会，包括money。<\/p>\n<p>大家都疑惑的一个问题是如何在这样巨变的时代能够通过学习来应变，我可以很负责的告诉大家，没有捷径，但通过掌握 Node.js 能够让你降低这个学习曲线而已，毕竟Node.js是大前端的基础设施。大家可以看一下，前端的开发过程，模块化，构建，辅助工具，调优，架构调整，可以说Node.js是无处不在的。<\/p>\n<p>其实，辅助大前端开发只是Node.js的一个非常无心插柳的衍生功能，通过掌握Node.js能够让你能做的更多、获得的更多，甚至可以说有更多自我实现的快乐，在后面的章节会详细讲解Node.js的具体应用场景好处，这也是本书名字里\u201c更了不起的\u201d要去阐述的内容。<\/p>\n<p>综上种种，就是我一直提倡以 JavaScript 语言为中心的 <code>Node全栈<\/code> 概念的缘由，JavaScript 覆盖所有前端，Node.js 擅长做 I/O 密集型的后端，外加辅助开发的各种基础设施，无疑是工作、学习和成为快速掌握全栈技术最好的途径。你会的越多，你能做的就更多，你的人生也将会有不一样的精彩篇章。<\/p>\n<h1>补充<\/h1>\n<h2>没有领袖？<\/h2>\n<p>笑死了，根本就是外行，Node的接力棒是 TJ 和 sindresorhus ？ryan走了， Isaac Schlueter接✋的好么，然后是TJ Fontaine。之后闹出了iojs分裂问题，后来促使joyent不得不妥协，成立Node基金会。\n现在是纯社区玩法，背后是Node基金会。<\/p>\n<p>可以说，任何人离开都不会有特别大影响。铁打的营盘流水的兵，而已。<\/p>\n<p>TJ是想对Node改进的，但Node的负担太重了，现有体系和机制改变不是易事，而且也没有动力促使它改变。很多特性都是意淫的，根本不是Node设计的场景，所以说这些没意义。响马大哥的fibjs就是一个不错的实践，但为什么二者不融合呢？。。。。因为没法真的没法这样做。。。<\/p>\n<h2>拿 express 和 Rails 对比，是一样东西么？<\/h2>\n<blockquote>\n<p>我知道不能把 Node 跟 Rails 一起比，因为一个是平台，一个是框架。那我就详细拿 express 和Rails 比吧。express 可以说是提供了一个 RESTful API + MVC 的框架，本身既没有 orm 也没有提供各方面的脚手架（对比 Rails 的 scaffold）也没有提供任何主观性的集成（比如你需要自己搭建测试框架）<\/p>\n<\/blockquote>\n<p>进一步暴漏无知。express本身只是内核加了几个实用中间价的微型框架。Rails呢？是一个一站式的顶级Web框架。rails在2005年横空出世，node是2009年产生，exprss是2010年才有，这个比较客观么？<\/p>\n<p>谬误1:express 可以说是提供了一个 RESTful API + MVC 的框架<\/p>\n<p>a）谁说express是RESTful API了？<\/p>\n<p>明显要自己规约才能实现的，这也意淫到express上。。。sinatra呢，beego，Revel，Martini呢？<\/p>\n<p>express上实现rest可以，但不能这叫。<\/p>\n<pre class=\"prettyprint\"><code>var express = require(&#x27;express&#x27;);\nvar router = express.Router();\n\nvar $ = require(&#x27;..&#x2F;controllers&#x2F;users_controller&#x27;);\n\n&#x2F;&#x2F; -- custom\n\n&#x2F;**\n * Auto generate RESTful url routes.\n *\n * URL routes:\n *\n *  GET    &#x2F;users[&#x2F;]        =&gt; user.list()\n *  GET    &#x2F;users&#x2F;new       =&gt; user.new()\n *  GET    &#x2F;users&#x2F;:id       =&gt; user.show()\n *  GET    &#x2F;users&#x2F;:id&#x2F;edit  =&gt; user.edit()\n *  POST   &#x2F;users[&#x2F;]        =&gt; user.create()\n *  PATCH  &#x2F;users&#x2F;:id       =&gt; user.update()\n *  DELETE &#x2F;users&#x2F;:id       =&gt; user.destroy()\n *\n *&#x2F;\n\nrouter.get(&#x27;&#x2F;new&#x27;, $.new);  \nrouter.get(&#x27;&#x2F;:id&#x2F;edit&#x27;, $.edit);\n\nrouter.route(&#x27;&#x2F;&#x27;)\n  .get($.list)\n  .post($.create);\n\nrouter.route(&#x27;&#x2F;:id&#x27;)\n  .patch($.update)\n  .get($.show)\n  .delete($.destroy);\n\n\nmodule.exports = router;\n<\/code><\/pre><p>b）谁说express是MVC了？<\/p>\n<p>express目录有router和view就算mvc了？呵呵，看看rails，thinkjs，eggjs行么？<\/p>\n<pre class=\"prettyprint\"><code>├── app.js\n├── bin\n│   └── www\n├── package.json\n├── public\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes\n│   ├── index.js\n│   └── users.js\n└── views\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n\n7 directories, 9 files\n<\/code><\/pre><p>c）谁说express是和rails一样的框架了？<\/p>\n<p>你可以这也理解express只是内核（插件机制） + 几个常用插件。是一个麻雀虽小，五脏俱全的微型框架。一个连基本约定，orm，脚手架，migrate都没有的框架也算框架？<\/p>\n<p>express不会直接使用的。大部分情况都是要自己封装的，如果说直接拿express-generator做事儿，做分析的，那真是用浅尝辄止形容不为过。<\/p>\n<p>d）说express不如rails<\/p>\n<p>确实不如，本来就不是一样的东西。ruby诞生自93年，rails诞生2005年，node和express呢？<\/p>\n<p>起点不一样，比较有意义么？<\/p>\n<h2>Node哲学 与 Left-pad事件始末，真了解？<\/h2>\n<blockquote>\n<p>Node 社区的哲学是可以把 left pad 作为一个包，这看起来真的很傻。<\/p>\n<\/blockquote>\n<p>明明不知道事件始末就乱发表意见，是否得当？是够傻的。<\/p>\n<p>2016年3月份，kik是Azer写的模块，但Kik同时是手机通信录的社交软件，所以这个社交软件上就无耻的直接说让Azer把kik名字给他们，Azer不同意，他们就拿律师函恐吓，并让npm妥协，所以npm就妥协了<\/p>\n<p>Azer一怒之下将自己在 npm 上的 273 个封包全部撤下，其中就包括 left-pad 封包。一石激起千层浪，依赖 left-pad 的上千个项目包括 babel 和 react-native 瞬间崩溃。大量开发者看着自己项目构建失败，顿时被吓尿。<\/p>\n<p>观点<\/p>\n<ul>\n<li>\n<p>1）就没见过这么傻逼的公司，一个红包就能解决的事儿，非要用强权，如果对方在改模块上耗费心血少的话，转给你也是可以商量的。<\/p>\n<\/li>\n<li>\n<p>2）11行代码要不要封装成一个包？<\/p>\n<\/li>\n<\/ul>\n<blockquote>\n<p>sindresorhus: Containing complexity is not about putting everything in one-line functions/modules.<\/p>\n<\/blockquote>\n<p>社区一致认可的结论：你的模块必须含有一定的复杂性，不然就没啥意义了。<\/p>\n<ul>\n<li>3）npm上那么多个模块，大多数都是无意义的吧？<\/li>\n<\/ul>\n<p>从我开始讲<a href=\"https://github.com/i5ting/nodejs-fullstack\">Node.js全栈<\/a>大约是3月份，那是npm上是25.6万个吧，截止到2017年3月是45万个，我想说的是那个包仓库都是有好有坏，按照80/20原则，数量是也是相当可观的。总比那些某些语言连包管理机制都不完善的要强太多了吧！<\/p>\n<ul>\n<li>4）<a href=\"http://blog.npmjs.org/post/141905368000/changes-to-npms-unpublish-policy\">迫使npm调整了撤销策略<\/a>，模块一旦发布，24小时之后就不让撤销了<\/li>\n<\/ul>\n<blockquote>\n<p>If the version is less than 24 hours old, you can unpublish it. The package will be completely removed from the registry.<\/p>\n<\/blockquote>\n<h2>这世界是完美的？<\/h2>\n<pre class=\"prettyprint\"><code>没用过别逼逼我不同意，我在做新的项目之前仔细对比了 Node Web 框架与其他框架，发现 Node 的上述问题，才使用了别的。\n我不认为我一定要用过之后再来逼逼。\n你也是做过项目的，知道如果一个项目做毁了会有多大损失，我不会为了来逼逼而去做毁一个项目。\n如果你技术一般，我建议你先别用 Node，因为会让你的技术更一般。\n如果你技术很牛，我不需要建议你什么，你牛你先说。\n<\/code><\/pre><p>没用过就是没用过，很多精髓的东西如果停留在表面，是不是太肤浅了？哪个框架是完美的？了解敏捷么？敏捷的基础认知是什么？<\/p>\n<p>从上面那express和rails比，从对express是rest+mvc的描述，暴漏对node了解太浅。如果说想黑node，我再帮你补二刀，早年robbin范凯，一直在黑node的回调地狱，可是又如何呢？该有多人用还是有多少人用<\/p>\n<p>有种你别装，装了就别瞎比比，既想当婊子，又想立牌坊吗？<\/p>\n<p>至于项目能否做成功，我并不认为是技术的问题。更多的是你对技术的熟练程度，哪个熟悉就用哪个，你哪个自己不熟悉的，做毁了，然后来骂框架，骂语言？这也是神逻辑啊。<\/p>\n<p>狼叔经常说：\u201c少抱怨，多思考，未来更美好\u201d，适用于所有人。<\/p>\n<h2>人员参差不齐要说人员参差不齐， Node 社区说第二，有哪个敢说第一？<\/h2>\n<pre class=\"prettyprint\"><code>PHP 好歹也是专注 Web 后台。Node 可笑的地方在于一群前端以为自己会后端就来写 Web 后台。我没有数据支持，但是我就是这么认为的。\nJava 后台的新人也是第一天就会专注于后台方面的学习。\n当然这并不能作为你不使用 Node 的原因，如果你是大神，你不会在乎这个社区有多少小白的。但是我前面也说了，我关注的大神都从 Node 社区走了啊。我为什么还要进 Node 社区\u2026\u2026\n阿里的苏千我在阿里的时候也有向他请教 Node 方面的知识，我从未否认他们的贡献，不过我并不会因此捧 Node。\n<\/code><\/pre><p>PHP专注于Web 后台，我估计看了这话，鸟哥会哭的很伤心的。Node的人不是可笑，是有追求，慢慢写着写着就在成长。<\/p>\n<p>Java 后台的新人也是第一天就会专注于后台方面的学习？呵呵，没学Java么？去看看core java吧，上来学后台，没见过。<\/p>\n<p>关注的大神都从 Node 社区走了，这话更扯淡。哪个社区不是这样的？不同年龄，职位，人生阶段，关注点会不一样的。比如严清zensh就从node转了go，人家职位也不一样了。再有说话不要用\u201c都\u201d，我举个例子朴灵，<a href=\"https://cnodejs.org/user/JacksonTian%EF%BC%8C%E5%A4%A7%E5%AE%B6%E5%8E%BB%E7%9C%8B%E7%9C%8B%E4%BB%96%E7%9A%84%E6%9C%80%E8%BF%91%E5%8F%82%E4%B8%8E%E7%9A%84%E8%AF%9D%E9%A2%98%EF%BC%8C10%E5%A4%A9%E5%89%8D%E7%9A%84%E3%80%82https://cnodejs.org/topic/5a20be0a110a338547d6e371#5a24c72b9178b0a14ac01e1b\">https://cnodejs.org/user/JacksonTian，大家去看看他的最近参与的话题，10天前的。https://cnodejs.org/topic/5a20be0a110a338547d6e371#5a24c72b9178b0a14ac01e1b<\/a><\/p>\n<p>最后，再说一件事儿，别老贴金，进了阿里不代表什么，马云说了，三年以上才算阿里人，才有阿里味。向玉伯，寒冬，苏千，朴灵，天猪等大大们致敬。<\/p>\n<h2>Hold 不住？<\/h2>\n<blockquote>\n<p>Node 呢，请问我该用什么数据库？用什么 ORM？用什么模板语言？用什么做后台任务？如何监控内存？如何分析日志？如何做分布式？如何做安全？有些人看说用 Node 做业务速度快，Node 的框架就做那么点低层次的封装，能不快吗？你把各种中间件加完试试？每个领域都要自己去找最佳实践，然后自己集成起来。<\/p>\n<\/blockquote>\n<p>先不论对node和express等理解错误的问题。<\/p>\n<p>先看狼叔之前的回复 <a href=\"https://www.zhihu.com/question/263855387/answer/273769595\">https://www.zhihu.com/question/263855387/answer/273769595<\/a><\/p>\n<p>一般，后端开发指的是 <code>Web<\/code> 应用开发中和视图渲染无关的部分，但现在架构升级，<code>Node<\/code> 承担了前后端分离重任之后，有了更多玩法。从带视图的传统 <code>Web应用<\/code> 和 <code>面向Api接口应用<\/code>，到通过 <code>RPC<\/code> 调用封装对数据库的操作，到提供前端 <code>Api<\/code> 代理和网关，服务组装等，统称为后端开发，不再是以往只有和数据库打交道的部分才算后端，这样，就可以让前端工程师对开发过程可控，更好的进行调优和性能优化。<\/p>\n<p>对Node.js来说，一直没有在后端取得其合理的占有率。原因很简单<\/p>\n<ul>\n<li>\n<p>1）利益分配，已有实现大多是Java或者其他语言，基本是没法撼动的，重写的成本是巨大的，另外，如果用Node写了，那么那些写Java的人怎么办？抢人饭碗，这是要拼命的。<\/p>\n<\/li>\n<li>\n<p>2）Node相对年轻，大家对Node的理解不够，回调和异步流程控制略麻烦，很多架构师都不愿意花时间去学习。尽管在Web应用部分处理起来非常简单高效，但在遇到问题时并不容易排查定位，对开发者水平要求略高。<\/p>\n<\/li>\n<li>\n<p>3）开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。<\/p>\n<\/li>\n<li>\n<p>4）Node在科普、培训、布道等方面做的并不好，国外使用的非常多，国内却很少人知道，不如某些语言做得好。<\/p>\n<\/li>\n<\/ul>\n<p>了不起是个不能随便说的词儿，对于 Node.js 来说，简化并发编程，用了不起来形容并不过分，在2009年横空出世时，确实是独一无二的。但在今天，已经8岁的 Node.js 有了更多、更为广泛的应用场景，它已经远远大于当初设计时的初衷了，我觉得用更了不起来形容已经不过分了！<\/p>\n<p>你这个问题，很明显暴漏了自己的问题就是上面的原因之3。<\/p>\n<blockquote>\n<p>开发者技能单一，很多是从前端转过来的，对数据库，架构方面知识欠缺，对系统设计也知之不多，这是很危险的，有种麻杆打狼两头害怕的感觉。<\/p>\n<\/blockquote>\n<p>不懂架构，不懂数据库，还没有明白人带，那你用啥框架，语言能好呢？<\/p>\n<ul>\n<li>1）复用已有基础设施，很明显比自己造轮子好。别动不动就java已死，xx已死的，冰冻三尺非一日之寒<\/li>\n<li>2）微服务架构下，你需要多复杂？<\/li>\n<\/ul>\n<p>不懂不可怕，别装懂。<\/p>\n<h2>UI 是 User Inferface，意思是 Node 社区做的工具的外观（UI）都很漂亮。<\/h2>\n<blockquote>\n<p>pm2 的 UI（命令行界面）我就很喜欢，Node 内容 Chrome 调试（界面）我也很喜欢，这是 UI，我不是说 GUI。程序员之间说 UI 难道不是既包括 GUI 又包括 CLI 吗？这只是对于术语的误解而已，不重要。<\/p>\n<\/blockquote>\n<p>各位看官自己判断这句话吧。<\/p>\n<h2>所以 NodeJS 社区很明智，多多模仿其他成熟框架是对的。但我直接去看你模仿的框架就好。？<\/h2>\n<p>举例，我想学日语，结果发现日语里有汉语的影子，于是我去学了汉语？是这逻辑么？<\/p>\n<p>水是原子组成的，干嘛喝水呢？去喝原子啊，反正有很多途径。。。<\/p>\n<h2>JS 全栈<\/h2>\n<blockquote>\n<p>我不知道这有什么意义？为了全栈而全栈？Java 二十年前也有一样的口号，然后呢？而且 JS 现在已经很奇怪了。<\/p>\n<\/blockquote>\n<p>目前看js是最容易实现全栈的途径，没有之一。我很喜欢ror，但同时学2种还是略难。其他就更不要说了。Java是跨平台，能和JS一样么？你真的了解从applet到awt到swing到他们衰亡的历史么？不见得吧，说话还是要有理有据的。<\/p>\n<p>全栈是信仰，是一种积极的人生态度。何谓为了全栈而全栈?我看到的更多的是大家积极的学习，努力的向提高成长。在技术变化如此快的今天，我们不是更该如此么？我尊重每一个有全栈信仰的人，我也祝福你们，未来是你们的。<\/p>\n<p>关于语言他回复的2个点<\/p>\n<ul>\n<li>我对Node新人的建议是玩一玩可以，不过要早点转 Go，因为 Node 并没有什么突出的优势。<\/li>\n<li>我宁愿用 Java 都不会用 Node.js，除非工资特别高<\/li>\n<\/ul>\n<p>一会扯go，一会扯java，难道对这门语言很熟悉的？还是纯粹为了挑起语言战争？还是为了培训机构站台？<\/p>\n<p>大家姑妄言之，姑妄笑之就好，别认真，认真你就输了<\/p>\n<p>朴大说过：\u201c为什么非要尝试去说服傻逼\u201d，可怜之人必有可恨之处，但不容许有人黑我大Node。<\/p>\n<\/div>","title":"狼叔回复的《Node相比传统服务端技术栈好在哪里？》","last_reply_at":"2019-03-12T01:05:22.919Z","good":true,"top":false,"reply_count":28,"visit_count":8864,"create_at":"2017-12-14T14:23:35.819Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"583c5d9fba57ffba06c24a89","author_id":"574baf9e991011691ef17ca6","tab":"share","content":"<div class=\"markdown-text\"><h2>为啥要搞这玩意？<\/h2>\n<p>今天老板提了需求，要在服务端生成邀请卡，嗯\u2026，简单的说就是把要这张：\n<img src=\"//static.cnodejs.org/Fvbe3rk65Xd6tLEJcYSgQLt6J2up\" alt=\"webwxgetmsgimg.jpg\">\n变成差多这样的：\n<img src=\"//static.cnodejs.org/FpN6RbDjbnz2fzxsqo-PinRK-5LX\" alt=\"card.png\">\n后端搞ruby的哥们搞了个html转图片，说转得太慢了，我就把这坑接下来了\n所以睡前就倒腾了下，搞了个简单的实现<\/p>\n<h2>解决思路<\/h2>\n<p>文字转svg -&gt; svg转png -&gt; 合并图片<\/p>\n<h2>相关轮子<\/h2>\n<ul>\n<li>images Node.js 轻量级跨平台图像编解码库，不需要额外安装依赖<\/li>\n<li>text-to-svg  文字转svg<\/li>\n<li>svg2png svg转png图片<\/li>\n<\/ul>\n<h2>示例代码<\/h2>\n<pre class=\"prettyprint\"><code>&#x27;use strict&#x27;;\n\nconst fs = require(&#x27;fs&#x27;);\nconst images = require(&#x27;images&#x27;);\nconst TextToSVG = require(&#x27;text-to-svg&#x27;);\nconst svg2png = require(&quot;svg2png&quot;);\nconst Promise = require(&#x27;bluebird&#x27;);\n\nPromise.promisifyAll(fs);\n\nconst textToSVG = TextToSVG.loadSync(&#x27;fonts&#x2F;文泉驿微米黑.ttf&#x27;);\n\nconst sourceImg = images(&#x27;.&#x2F;i&#x2F;webwxgetmsgimg.jpg&#x27;);\nconst sWidth = sourceImg.width();\nconst sHeight = sourceImg.height();\n\nconst svg1 = textToSVG.getSVG(&#x27;魏长青-人人讲App&#x27;, {\n  x: 0,\n  y: 0,\n  fontSize: 24,\n  anchor: &#x27;top&#x27;,\n});\n\nconst svg2 = textToSVG.getSVG(&#x27;邀请您参加&#x27;, {\n  x: 0,\n  y: 0,\n  fontSize: 16,\n  anchor: &#x27;top&#x27;,\n});\n\nconst svg3 = textToSVG.getSVG(&#x27;人人讲课程&#x27;, {\n  x: 0,\n  y: 0,\n  fontSize: 32,\n  anchor: &#x27;top&#x27;,\n});\n\nPromise.coroutine(function* generateInvitationCard() {\n  const targetImg1Path = &#x27;.&#x2F;i&#x2F;1.png&#x27;;\n  const targetImg2Path = &#x27;.&#x2F;i&#x2F;2.png&#x27;;\n  const targetImg3Path = &#x27;.&#x2F;i&#x2F;3.png&#x27;;\n  const targetImg4Path = &#x27;.&#x2F;i&#x2F;qrcode.jpg&#x27;;\n  const [buffer1, buffer2, buffer3] = yield Promise.all([\n    svg2png(svg1),\n    svg2png(svg2),\n\tsvg2png(svg3),\n  ]);\n\n  yield Promise.all([\n    fs.writeFileAsync(targetImg1Path, buffer1),\n    fs.writeFileAsync(targetImg2Path, buffer2),\n    fs.writeFileAsync(targetImg3Path, buffer3),\n  ]);\n\n  const target1Img = images(targetImg1Path);\n  const t1Width = target1Img.width();\n  const t1Height = target1Img.height();\n  const offsetX1 = (sWidth - t1Width) &#x2F; 2;\n  const offsetY1 = 200;\n\n  const target2Img = images(targetImg2Path);\n  const t2Width = target2Img.width();\n  const t2Height = target2Img.height();\n  const offsetX2 = (sWidth - t2Width) &#x2F; 2;\n  const offsetY2 = 240;\n\n  const target3Img = images(targetImg3Path);\n  const t3Width = target3Img.width();\n  const t3Height = target3Img.height();\n  const offsetX3 = (sWidth - t3Width) &#x2F; 2;\n  const offsetY3 = 270;\n\n  const target4Img = images(targetImg4Path);\n  const t4Width = target4Img.width();\n  const t4Height = target4Img.height();\n  const offsetX4 = (sWidth - t4Width) &#x2F; 2;\n  const offsetY4 = 400;\n\n  images(sourceImg)\n  .draw(target1Img, offsetX1, offsetY1)\n  .draw(target2Img, offsetX2, offsetY2)\n  .draw(target3Img, offsetX3, offsetY3)\n  .draw(target4Img, offsetX4, offsetY4)\n  .save(&#x27;.&#x2F;i&#x2F;card.png&#x27;, { quality : 90 });\n})().catch(e =&gt; console.error(e));\n<\/code><\/pre><h2>注意事项<\/h2>\n<ul>\n<li>text-to-svg需要中文字体的支持，不然中文会乱码<\/li>\n<\/ul>\n<p>在我的破电脑上执行一次只花了500多毫秒，感觉足够了，分享出来希望能给大家一个参照\n厚脸皮的问一下，能加个精不？😂<\/p>\n<\/div>","title":"node文字转图片","last_reply_at":"2019-03-08T01:33:45.839Z","good":true,"top":false,"reply_count":11,"visit_count":5359,"create_at":"2016-11-28T16:38:55.229Z","author":{"loginname":"Amastyer","avatar_url":"https://avatars1.githubusercontent.com/u/12872492?v=4&s=120"}},{"id":"5c46759e3b948a2b4ab70483","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：<\/strong> JS的&quot;编译原理&quot;。<\/p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000017961297\">JavaScript的工作原理：解析、抽象语法树（AST）+ 提升编译速度5个技巧<\/a><\/li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智<\/a><\/li>\n<\/ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug<\/a>经授权转载，版权归原作者所有。<\/strong><\/p>\n<p>这是专门探索 JavaScript 及其所构建的组件的系列文章的第 14 篇。<\/p>\n<p>如果你错过了前面的章节，可以在这里找到它们：<\/p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000017352941\">JavaScript 是如何工作的：引擎，运行时和调用堆栈的概述！<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017369465\">JavaScript 是如何工作的：深入V8引擎&amp;编写优化代码的5个技巧！<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017392370\">JavaScript 是如何工作的：内存管理+如何处理4个常见的内存泄漏 !<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017419328\">JavaScript 是如何工作的：事件循环和异步编程的崛起+ 5种使用 async/await 更好地编码方式！<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017448270\">JavaScript 是如何工作的：深入探索 websocket 和HTTP/2与SSE +如何选择正确的路径！<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017485968\">JavaScript 是如何工作的：与 WebAssembly比较 及其使用场景 !<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017578650\">JavaScript 是如何工作的：Web Workers的构建块+ 5个使用他们的场景!<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017749922\">JavaScript 是如何工作的：Service Worker 的生命周期及使用场景!<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017794020?_ea=6014340#articleHeader0\">JavaScript 是如何工作的：Web 推送通知的机制!<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017832686\">JavaScript是如何工作的：使用 MutationObserver 跟踪 DOM 的变化!<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017872125#articleHeader0\">JavaScript是如何工作的：渲染引擎和优化其性能的技巧!<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017903157\">JavaScript是如何工作的：深入网络层 + 如何优化性能和安全!<\/a><\/li>\n<li><a href=\"https://segmentfault.com/a/1190000017927665\">JavaScript是如何工作的：CSS 和 JS 动画底层原理及如何优化它们的性能！<\/a>-<\/li>\n<\/ul>\n<h3>概述<\/h3>\n<p>我们都知道运行一大段 JavaScript 代码性能会变得很糟糕。这段代码不仅需要通过网络传输，而且还需要解析、编译成字节码，最后执行。在之前的文章中，我们讨论了 JS 引擎、运行时和调用堆栈等，以及主要由谷歌 Chrome 和 NodeJS 使用的V8引擎。它们在整个 JavaScript 执行过程中都发挥着至关重要的作用。这篇说的抽象语法树同样重要:在这我们将了解大多数 JavaScript 引擎如何将文本解析为对机器有意义的内容，转换之后发生的事情以及做为 Web 开发者如何利用这一知识。<\/p>\n<h3>编程语言原理<\/h3>\n<p>那么，首先让我们回顾一下编程语言原理。不管你使用什么编程语言，你需要一些软件来处理源代码以便让计算机能够理解。该软件可以是解释器，也可以是编译器。无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 <strong>抽象语法树(abstract syntax tree, AST)<\/strong> 的数据结构。<\/p>\n<p><strong>AST<\/strong> 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。<\/p>\n<blockquote>\n<p>抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦 AST 被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。<\/p>\n<\/blockquote>\n<h3>AST 程序<\/h3>\n<p>AST 不仅仅是用于语言解释器和编译器，在计算机世界中，它们还有多种应用。使用它们最常见的方法之一是进行静态代码分析。静态分析器不执行输入的代码，但是，他们仍然需要理解代码的结构。<\/p>\n<p>例如，你可能想要实现一个工具，该工具可以找到公共代码结构，以便你可以重构它们以减少重复。你可能会通过使用字符串比较来实现这一点，但这个会相当简单且有局限性。<\/p>\n<p>当然，如果你对实现这样的工具感兴趣，你不需要编写自己的解析器。有许多与 Ecmascript规范完全兼容的开源项目。<strong>Esprima<\/strong> 和 <strong>Acorn<\/strong> 即是黄金搭档，还有许多工具可以帮助解析器生成输出，即 <strong>ASTs<\/strong> ，ASTs 被广泛应用于代码转换。<\/p>\n<p>例如，你可能希望实现一个将 Python 代码转换为J avaScript 的转换器。基本思想是使用Python 转换器生成 AST，然后使用 AST 生成JavaScript代码。<\/p>\n<p>你可能会觉得难以置信，事实是 ASTs 只是部分语言的不同表示法。在解析之前，它被表示为遵循一些规则的文本，这些规则构成了一种语言。在解析之后，它被表示为一个树结构，其中包含与输入文本完全相同的信息。因此，也可以进行反向解析然后回到文本。<\/p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具<a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug<\/a>。<\/strong><\/p>\n<h3>JavaScript 解析<\/h3>\n<p>让我们看看 AST 是如何构建的。我们用一个简单的 JavaScript 函数作为例子:<\/p>\n<pre class=\"prettyprint language-javascript\"><code>function foo(x) {\n    if (x &gt; 10) {\n        var a = 2;\n        return a * x;\n    }\n\n    return x + 10;\n}\n<\/code><\/pre><p>解析器会产生如下的 AST：<\/p>\n<p><img src=\"https://image.fundebug.com/2019-01-21-01.png\" alt><\/p>\n<p>注意，为了观看方便，这里是解析器将生成的结果的简化版本。实际的 AST 要复杂得多。然而，这里的目的是为了运行源码之前的第一个步骤前。如果人想查看实际的 AST 是什么样子，可以访问 <a href=\"https://astexplorer.net/\">AST Explorer<\/a>。它是一个在线工具，你以在其中输入一些 JavaScript 并输出对应的 AST。<\/p>\n<p>你可能会问，为什么需要知道 JavaScript解析器工作原理，毕竟这是浏览器工作，你想法是部分正确。下图展示了 JavaScript 执行过程中不同阶段的耗时。仔细瞅瞅，你或许会发现一些有趣的东西。<\/p>\n<p><img src=\"https://image.fundebug.com/2019-01-21-02.png\" alt><\/p>\n<p>发现没？ 通常情况下，浏览器解析 JavaScript 大约需占总执行时间的 <code>15%<\/code> 到 <code>20%<\/code>。我没有具体统计过这些数值。这些是来自真实应用程序和以某种方式使用 JavaScript 的网站的统计数据。也许 <code>15%<\/code> 看起来不是很多，但相信我，这是很多。<\/p>\n<p>一个典型的单页程序加载 0.4 mb 左右的 JavaScript，浏览器需要大约 <code>370ms<\/code> 来解析它。也许你会又说，这也不是很多嘛，本身花费的时间并不多。但请记住，这只是将 JavaScript 代码解析为 AST 所需要的时间。这并不包括运行本身的时间，也不包括在页面加载 ，如 CSS 和 HTML 渲染过程的耗时。这些还只涉及桌面，移动浏览器的情况会更加复杂，在手机上花在解析上的时间通常是桌面浏览器的 2 到 5 倍。<\/p>\n<p><img src=\"https://image.fundebug.com/2019-01-21-03.jpeg\" alt><\/p>\n<p>上图显示了 1MB JavaScript 包在不同类的移动和桌面浏览器解析时间。<\/p>\n<p>更重要的是，为了获得更多类原生的用户体验而把越来越多的业务逻辑堆积在前端，Web 应用程序正变得越来越复杂。你可以轻易地想到网络应用受到的性能影响。只需打开浏览器开发工具，然后使用该工具来解析、编译和浏览器中发生的所有其他事情上所消耗的时间。<\/p>\n<p><img src=\"https://image.fundebug.com/2019-01-21-04.jpeg\" alt><\/p>\n<p>不幸的是，移动浏览器上没有开发者工具。不过不用担心，这并不意味着你对此无能为力。因为有 <a href=\"https://github.com/danielmendel/DeviceTiming\">DeviceTiming<\/a> 工具,它可以用来帮助检测受控环境中脚本的解析和运行时间。它通过插入代码来封装本地代码，这样每次从不同的设备访问页面时，就可以在本地测量解析和运行时间。<\/p>\n<p>好事就是 JavaScript 引擎做了很多工作来避免冗余的工作，并得到了更好的优化，以下为主流浏览器使用的技术。<\/p>\n<p>例如，V8 实现脚本流(script streaming)和代码缓存技术。脚本流即脚本一旦开始下载，<code>async<\/code> 和 <code>deferred<\/code>的 脚本就会在单独的线程上解析。这意味着在下载脚本完成后几乎立即完成解析，这会提升 10% 的页面加载速度。<\/p>\n<p>每次访问页面时，JavaScript 代码通常编译为字节码。 然而，一旦用户访问另一页面，该字节码就被丢弃。 发生这种情况是因为编译后的代码很大程度上依赖于编译时机器的状态和上下文。 这是 Chrome 42 引入字节码缓存的原因。 该技术会本地缓存编译过的代码，这样当用户返回同一页面时，诸如下载，解析和编译等所有步骤都会被跳过。 这使得 Chrome 可以节省大约 40％ 的解析和编译时间。 此外，这还可以节省移动设备的电量。<\/p>\n<p>在 Opera 中，<a href=\"https://dev.opera.com/blog/carakan/\">Carakan<\/a> 引擎可以重用另一个程序最近编译过的输出。没有要求代码必须来自相同的页面甚至同个域下。这种缓存技术实际上非常高效，还可以完全跳过编译步骤。它依赖于典型的用户行为和浏览场景:每当用户在应用程序/网站中遵循某个用户的特定浏览习惯，都会加载相同的 JavaScript 代码。不过，Carakan 引擎早已被谷歌的 V8 所取代。<\/p>\n<blockquote>\n<p>Opera 新的 JavaScript 引擎 \u201cCarakan\u201d，目前速度是其他已存在 JavaScript 引擎（基于 SunSpider）的2.5倍。其在转化为本地机器代码时专门针对正则表达式做了优化。<\/p>\n<\/blockquote>\n<p>Firefox 使用的 <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey\">SpiderMonkey<\/a> 引擎不会缓存所有内容。它可以过渡到监视阶段，在这个阶段中，它计算执行给定脚本的次数。基于此计算，它推导出频繁使用而可以被优化的代码部分。<\/p>\n<blockquote>\n<p>SpiderMonkey 是 Mozilla 项目的一部分，是一个用 C 语言实现的 JavaScript 脚本引擎，另外还有一个叫做Rhino 的 Java 版本。<\/p>\n<\/blockquote>\n<p>显然，有些人决定什么都不做。Safari 的首席开发人员 <a href=\"https://en.wikipedia.org/wiki/Maciej_Stachowiak\">Maciej Stachowiak<\/a> 表示，Safari 不会对编译后的字节码进行任何缓存。缓存技术他们是有考虑过的问题，但是他们还没有实现，因为生成代码的耗时小于总运行时间的 2%。<\/p>\n<p>这些优化不会直接影响 JavaScript 源代码的解析，但是会尽可能完全避免。毕竟做总比没做好点？<\/p>\n<p>我们可以做很多事情来改善应用程序的初始加载时间。最小化加载的 JavaScript 数量：代码越小、解析所需要时间就越少，运行时间也就越小。要做到这一点，我们只能在当前的路由上加载所需的代码，而不是加载一大陀的代码。例如，<a href=\"https://developers.google.com/web/fundamentals/performance/prpl-pattern/\">PRPL模式<\/a>即表示该种代码传输类型。或者，可以检查代码的依赖关系，看看是否有什么冗余的依赖导致代码库膨胀，然而，这些东西需要很大的篇幅来进行讨论。<\/p>\n<p>本文的主要的目的讨论作为 Web 开发人员可以做些什么来帮助 JavaScript 解析器更快地完成它的工作。还有,现代JavaScript 解析器使用 <strong>启发法(heuristics)<\/strong> 来决定是否立即运行指定的代码片段或者推迟在未来的某个时候运行。基于这些启发法，解析器将进行即时或懒解析。<\/p>\n<blockquote>\n<p>启发法是针对模型求解方法而言的，是一种逐次逼近最优解的方法。这种方法对所求得的解进行反复判断实践修正直至满意为止。启发法的特点是模型简单，需要进行方案组合的个数少，因此便于找出最终答案。此方法虽不能保证得到最优解，但只要处理得当，可获得决策者满意的近似最优解。一般步骤包括:定义一个计算总费用的方法;报定判别准则;规定方案改选的途径;建立相应的模型;送代求解。<\/p>\n<\/blockquote>\n<p>立即解析会运行需要立即编译的函数。它主要做三件事:构建 AST，构建作用域层级和查找所有语法错误。另一方面， 懒解析只运行未编译的函数。它不构建AST，也不查找所有语法错误，它只构建作用域层级，与立即解析相比节省了大约一半的时间。<\/p>\n<p>显然，这不是一个新概念。即使像 IE 9 这样的浏览器也支持这种类型的优化，尽管与现在的解析器的工作方式相比，这种优化方式还很初级。<\/p>\n<p>来看一个例子，假设有以下代码片段:<\/p>\n<pre class=\"prettyprint language-javascript\"><code>function foo() {\n    function bar(x) {\n        return x + 10;\n    }\n\n    function baz(x, y) {\n        return x + y;\n    }\n\n    console.log(baz(100, 200));\n}\n\nfoo()\n<\/code><\/pre><p>就像前面的例子一样，代码被输入到语法分析器中，语法分析器进行语法分析并输出AST，如下：<\/p>\n<ul>\n<li>声明函数 <code>foo<\/code><\/li>\n<li>调用函数 <code>foo<\/code><\/li>\n<li>在 <code>foo<\/code> 里声明函数 <code>bar<\/code> 接收参数 <code>x<\/code>, 并返回 <code>x<\/code> 和 10 相加的结果<\/li>\n<li>在 <code>foo<\/code> 里声明函数 <code>baz<\/code> 接收参数 <code>x<\/code>和 <code>y<\/code>, 并返回 <code>x<\/code> 和 <code>y<\/code> 相加的结果<\/li>\n<li>调用 <code>baz<\/code> 函数传入 100 和 2。<\/li>\n<li>调用 <code>console.log<\/code> 参数为之前函数调用的返回值。<\/li>\n<\/ul>\n<p><img src=\"https://image.fundebug.com/2019-01-21-05.png\" alt><\/p>\n<p>那么期间发生了什么? 解析器看到 <code>bar<\/code> 函数的声明、<code>baz<\/code> 函数的声明、<code>bar<\/code>函数的调用和 <code>console.log<\/code> 的调用。但是，解析器做了一些完全无关的额外工作即解析 <code>bar<\/code> 函数。为什么这无关紧要? 因为函数 <code>bar<\/code> 从来没有被调用过(或者至少在那个时候没有)。这是一个简单的示例，看起来可能有些不同寻常，但在许多实际应用程序中，许多声明的函数从未被调用。<\/p>\n<p>这里不解析<code>bar<\/code>函数，该函数声明了却没有调用它。只在需要的时候在函数运行前进行真正的解析。懒解析仍然需要找到函数的整个主体并为其声明，但仅此而已。它不需要语法树，因为它还没有被处理。另外，它不会从堆中分配内存，而堆通常会占用相当多的系统资源，简而言之，跳过这些步骤会带来很大的性能改进。<\/p>\n<p>所以之前的例子，解析器实际上会像如下这样解析：<\/p>\n<p><img src=\"https://image.fundebug.com/2019-01-21-06.png\" alt><\/p>\n<p>注意，这里只确认 <code>bar<\/code> 函数声明，没有进入 <code>bar<\/code> 函数体。在这种情况下，函数体只是一个返回语句。但是，与大多数实际应用程序一样，它可以更大，包含多个返回语句、条件语句、循环、变量声明，甚至嵌套函数声明。这完全是在浪费时间和系统资源，因为这个函数永远不会被调用。<\/p>\n<p>这是一个相当简单的概念，但实际上，它的实现是非常难的，不局限于以上示例。整个方法还可以适用于函数、循环、条件、对象等。基本上，所有需要解析的东西。<\/p>\n<p>例如，下面是一个非常常见的 JavaScript 模式。<\/p>\n<pre class=\"prettyprint language-javascript\"><code>var myModule = (function() {\n     &#x2F;&#x2F; 整个模块的逻辑\n     &#x2F;&#x2F; 返回模块对象\n})();\n<\/code><\/pre><p>大多数现代 JavaScript 解析器都能识别这种模式，此模式表示代码需要立即解析。<\/p>\n<p>那么为什么解析器不都使用懒解析呢? 如果懒解析某些代码，这些代码需要立即执行，这实际上会使代码运行速度变慢。需要运行一次懒解析之后进行另一个立即解析，这和立即解析相比，运行速度会慢 50%。<\/p>\n<p>现在对解析器底层原理有了大致的了解，是时候考虑如何提高解析器的解析速度。可以用这种方式编写代码，以便在正确的时间解析函数。大多数解析器都能识别一种模式:使用括号封装函数。对于解析器来说，这几乎总是一个积极的信号，即函数需要立即执行。如果解析器看到一个左括号，紧接着是一个函数声明，它将立即解析这个函数。可以通过显式地声明立即执行的函数来帮助解析器加快解析速度。<\/p>\n<p>假设有一个名为 <code>foo<\/code> 的函数。<\/p>\n<pre class=\"prettyprint language-javascript\"><code>function foo(x) {\n    return x * 10;\n}\n<\/code><\/pre><p>因为没有明显地标识表明需要立即运行该函数所以浏览器会进行懒解析。然而，我们确定这是不对的，那么可以运行两个步骤。<\/p>\n<p>首先，将函数存储在一个变量中:<\/p>\n<pre class=\"prettyprint language-javascript\"><code>var foo = function foo(x) {\n    return x * 10;\n};\n<\/code><\/pre><p>注意，这里有使用函数的名称 <code>foo<\/code>,这不是必需的，但是建议这样做，因为在抛出异常的情况下，stacktrace 会保留实际函数名称，而不仅仅是 <code>&lt;anonymous&gt;<\/code>。<\/p>\n<p>以上事例解析器执行懒解析，可以用括号封装起来，让解析器进行立即解析：<\/p>\n<pre class=\"prettyprint language-javascript\"><code>var foo = (function foo(x) {\n    return x * 10;\n});\n<\/code><\/pre><p>现在，解析器看见 <code>function<\/code> 关键字前的左括号便会立即进行解析。<\/p>\n<p>因为需要知道解析器在哪些情况下执行懒解析或者立即解析，所以很难手动管理。此外，还需要花时间考虑是否立即调用某个函数，肯定没人想这么做的。<\/p>\n<p>最后，这种地让代码更难阅读和理解。可以使用 <code>Optimize.js<\/code> 可以帮我们做这类事情，该工具只是用来优化 JavaScript 源代码的初始加载时间，它们对代码进行静态分析，然后通过使用括号封装需要立即运行的函数以便浏览器立即解析并准备运行它们。<\/p>\n<p>像往常一样编码，然后有一段代码看起来像这样的：<\/p>\n<pre class=\"prettyprint language-javascript\"><code>(function() {\n    console.log(&#x27;Hello, World!&#x27;);\n})();\n<\/code><\/pre><p>一切看起来都很好，如预期的那样工作，而且速度很快，因为在函数声明之前添加左括号。当然，在进入生产环境之前需要进行代码压缩，以下为压缩工具的输出：<\/p>\n<pre class=\"prettyprint language-javascript\"><code>!function(){console.log(&#x27;Hello, World!&#x27;)}();\n<\/code><\/pre><p>好像没问题，代码像以前一样工作。但是好像少了什么，压缩工具删除包裹函数的括号，而是在函数前放置了一个感叹号，这意味着解析器将跳过此并将执行惰解析。<\/p>\n<p>最重要的是，为了能够执行该函数，它将在懒解析之后立即进行立即解析。 这会使代码运行得更慢，幸运的是，可以利用 <code>Optimize.js<\/code> 来解决此类问题，传给 <code>Optimize.js<\/code> 压缩过的代码会输出如下代码：<\/p>\n<pre class=\"prettyprint language-javascript\"><code>!(function(){console.log(&#x27;Hello, World!&#x27;)})();\n\n<\/code><\/pre><p>这还差不多，现在拥有两全其美方案：压缩代码且解析器正确地识别懒解析和立即解析的函数。<\/p>\n<h3>预编译<\/h3>\n<p>但为什么不能在服务器端完成所有这些工作呢？ 毕竟，最好这样做一次并将结果提供给客户端，而不强制各个客户端重复做该项事情。那么，目前正在讨论引擎是否应该提供一种执行预编译脚本的方法，这样就可以节省浏览器运行时间。<\/p>\n<p>从本质上讲，该思路是拥有可以生成字节码的务器端工具，这样只需要传输字节码并在客户端运行，之后会看到启动时间的一些主要差异。 这可能听起来很诱人，但事情并非那么简单，还可能会产生相反的效果，因为它会更大，并且很可能需要签署代码并出于安全原因对其进行处理。 例如，V8 团队正在努力解决重复解析问题，这样预编译有可能实际并没有多大的用处。<\/p>\n<h3>提升编译速度一些建议<\/h3>\n<ul>\n<li>检查依赖，减少不必要的依赖<\/li>\n<li>分割代码为更小的块而不是一整陀的<\/li>\n<li>尽可能推迟加载 JavaScript，按需要加载或者动态加载。<\/li>\n<li>使用开发者工具和 DeviceTiming 来检测性能瓶颈<\/li>\n<li>用像 Optimize.js 的工具来帮助解析器选择立即解析或者懒解析以加快解析速度<\/li>\n<\/ul>\n<p><strong>原文：<a href=\"https://blog.sessionstack.com/how-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8\">How JavaScript works: Parsing, Abstract Syntax Trees (ASTs) + 5 tips on how to minimize parse time<\/a><\/strong><\/p>\n<h3>关于Fundebug<\/h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug<\/a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用<\/a>！<\/p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt><\/p>\n<\/div>","title":"JavaScript的工作原理：解析、抽象语法树（AST）+ 提升编译速度5个技巧","last_reply_at":"2019-03-05T07:28:42.189Z","good":true,"top":false,"reply_count":10,"visit_count":2358,"create_at":"2019-01-22T01:45:02.116Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c7c8afc90c14711cc8c9dc7","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：<\/strong> Webpack骚操作。<\/p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000018368885\">Web 性能优化： 使用 Webpack 分离数据的正确方法<\/a><\/li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智<\/a><\/li>\n<\/ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug<\/a>经授权转载，版权归原作者所有。<\/strong><\/p>\n<p>制定向用户提供文件的最佳方式可能是一项棘手的工作。 有很多不同的场景，不同的技术，不同的术语。<\/p>\n<p>在这篇文章中，我希望给你所有你需要的东西，这样你就可以:<\/p>\n<ol>\n<li>了解哪种文件分割策略最适合你的网站和用户<\/li>\n<li>知道怎么做<\/li>\n<\/ol>\n<p>根据 <a href=\"https://webpack.js.org/glossary/\">Webpack glossary<\/a>，有两种不同类型的文件分割。 这些术语听起来可以互换，但显然不是。<\/p>\n<p>Webpack 文件分离包括两个部分，一个是 Bundle splitting，一个是 Code splitting:<\/p>\n<ul>\n<li><strong>Bundle splitting<\/strong>: 创建更多更小的文件，并行加载，以获得更好的缓存效果，主要作用就是使浏览器并行下载，提高下载速度。并且运用浏览器缓存，只有代码被修改，文件名中的哈希值改变了才会去再次加载。<\/li>\n<li><strong>Code splitting<\/strong>：只加载用户最需要的部分，其余的代码都遵从懒加载的策略，主要的作用就是加快页面的加载速度，不加载不必要的代码。<\/li>\n<\/ul>\n<p>第二个听起来更吸引人，不是吗?事实上，关于这个问题的许多文章似乎都假设这是制作更小的JavaScript 文件的惟一值得的情况。<\/p>\n<p>但我在这里要告诉你的是，第一个在很多网站上都更有价值，应该是你为所有网站做的第一件事。<\/p>\n<p>就让我们一探究竟吧。<\/p>\n<h3>Bundle splitting<\/h3>\n<p>bundle splitting 背后的思想非常简单，如果你有一个巨大的文件，并且更改了一行代码，那么用户必须再次下载整个文件。但是如果将其分成两个文件，那么用户只需要下载更改的文件，浏览器将从缓存中提供另一个文件。<\/p>\n<p>值得注意的是，由于 bundle splitting 都是关于缓存的，所以对于第一次访问来说没有什么区别。<\/p>\n<p>(我认为太多关于性能的讨论都是关于第一次访问一个站点，或许部分原因是\u201c第一印象很重要\u201d，部分原因是它很好、很容易衡量。<\/p>\n<p>对于经常访问的用户来说，量化性能增强所带来的影响可能比较棘手，但是我们必须进行量化!<\/p>\n<p>这将需要一个电子表格，因此我们需要锁定一组非常特定的环境，我们可以针对这些环境测试每个缓存策略。<\/p>\n<p>这是我在前一段中提到的情况:<\/p>\n<ul>\n<li>Alice 每周访问我们的网站一次，持续 10 周<\/li>\n<li>我们每周更新一次网站<\/li>\n<li>我们每周都会更新我们的\u201c产品列表\u201d页面<\/li>\n<li>我们也有一个\u201c产品详细信息\u201d页面，但我们目前还没有开发<\/li>\n<li>在第 5 周，我们向站点添加了一个新的 npm 包<\/li>\n<li>在第 8 周，我们更新了一个现有的 npm 包<\/li>\n<\/ul>\n<p>某些类型的人(比如我)会尝试让这个场景尽可能的真实。不要这样做。实际情况并不重要，稍后我们将找出原因。<\/p>\n<h3>基线<\/h3>\n<p>假设我们的 JavaScript 包的总容量是400 KB，目前我们将它作为一个名为 <code>main.js<\/code> 的文件加载。<\/p>\n<p>我们有一个 Webpack 配置如下(我省略了一些无关的配置):<\/p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; webpack.config.js \n\nconst path = require(&#x27;path&#x27;)\n\nmodule.exports = {\n  entry: path.resolve(__dirame, &#x27;src&#x2F;index.js&#x27;)\n  output: {\n    path: path.resolve(__dirname, &#x27;dist&#x27;),\n    filename: &#x27;[name].[contenthash].js&#x27;\n  }\n}\n<\/code><\/pre><p>对于那些新的缓存破坏：任何时候我说 <code>main.js<\/code>，我实际上是指 <code>main.xMePWxHo.js<\/code>，其中里面的字符串是文件内容的散列。这意味着不同的文件名 当应用程序中的代码发生更改时，从而强制浏览器下载新文件。<\/p>\n<p>每周当我们对站点进行一些新的更改时，这个包的 <code>contenthash<\/code> 都会发生变化。因此，Alice 每周都要访问我们的站点并下载一个新的 <code>400kb<\/code> 文件。<\/p>\n<p>如果我们把这些事件做成一张表格，它会是这样的。<\/p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-01.png\" alt><\/p>\n<p>也就是10周内， 4.12 MB, 我们可以做得更好。<\/p>\n<h3>分解 vendor 包<\/h3>\n<p>让我们将包分成 <code>main.js<\/code> 和 <code>vendor.js<\/code> 文件。<\/p>\n<pre class=\"prettyprint language-javascript\"><code> &#x2F;&#x2F; webpack.config.js \n\nconst path = require(&#x27;path&#x27;)\n\nmodule.exports = {\n  entry: path.resolve(__dirname, &#x27;src&#x2F;index.js&#x27;),\n  output: {\n    path: path.resolve(__dirname, &#x27;dist&#x27;),\n    filename: &#x27;[name].[contenthash].js&#x27;,\n  },\n  optimization: {\n    splitChunks: {\n      chunks: &#x27;all&#x27;\n    }\n  }\n}\n<\/code><\/pre><p>Webpack4 为你做最好的事情，而没有告诉你想要如何拆分包。这导致我们对 webpack 是如何分包的知之甚少，结果有人会问 \u201c你到底在对我的包裹做什么？\u201d<\/p>\n<p>添加 <code>optimization.splitChunks.chunks ='all'<\/code>的一种说法是 \u201c将 <code>node_modules<\/code> 中的所有内容放入名为 <code>vendors~main.js<\/code> 的文件中\u201d。<\/p>\n<p>有了这个基本的 bundle splitting，Alice 每次访问时仍然下载一个新的 200kb 的 <code>main.js<\/code>，但是在第一周、第8周和第5周只下载 200kb 的 <code>vendor.js<\/code> (不是按此顺序)。<\/p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-02.png\" alt><\/p>\n<p>总共：<strong>2.64 MB<\/strong>。<\/p>\n<p>减少36％。 在我们的配置中添加五行代码并不错。 在进一步阅读之前，先去做。 如果你需要从 Webpack 3 升级到 4，请不要担心，它非常简单。<\/p>\n<p>我认为这种性能改进似乎更抽象，因为它是在10周内进行的，但是它确实为忠实用户减少了36%的字节，我们应该为自己感到自豪。<\/p>\n<p>但我们可以做得更好。<\/p>\n<h3>分离每个 npm 包<\/h3>\n<p>我们的 <code>vendor.js<\/code> 遇到了与我们的 <code>main.js<\/code> 文件相同的问题\u2014\u2014对其中一部分的更改意味着重新下载它的所有部分。<\/p>\n<p>那么为什么不为每 个npm 包创建一个单独的文件呢?这很容易做到。<\/p>\n<p>所以把 <code>react<\/code>、<code>lodash<\/code>、<code>redux<\/code>、<code>moment<\/code> 等拆分成不同的文件:<\/p>\n<pre class=\"prettyprint language-javascript\"><code>const path = require(&#x27;path&#x27;);\nconst webpack = require(&#x27;webpack&#x27;);\n\nmodule.exports = {\n  entry: path.resolve(__dirname, &#x27;src&#x2F;index.js&#x27;),\n  plugins: [\n    new webpack.HashedModuleIdsPlugin(), &#x2F;&#x2F; so that file hashes don&#x27;t change unexpectedly\n  ],\n  output: {\n    path: path.resolve(__dirname, &#x27;dist&#x27;),\n    filename: &#x27;[name].[contenthash].js&#x27;,\n  },\n  optimization: {\n    runtimeChunk: &#x27;single&#x27;,\n    splitChunks: {\n      chunks: &#x27;all&#x27;,\n      maxInitialRequests: Infinity,\n      minSize: 0,\n      cacheGroups: {\n        vendor: {\n          test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]&#x2F;,\n          name(module) {\n            &#x2F;&#x2F; get the name. E.g. node_modules&#x2F;packageName&#x2F;not&#x2F;this&#x2F;part.js\n            &#x2F;&#x2F; or node_modules&#x2F;packageName\n            const packageName = module.context.match(&#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;](.*?)([\\\\&#x2F;]|$)&#x2F;)[1];\n\n            &#x2F;&#x2F; npm package names are URL-safe, but some servers don&#x27;t like @ symbols\n            return &#96;npm.${packageName.replace(&#x27;@&#x27;, &#x27;&#x27;)}&#96;;\n          },\n        },\n      },\n    },\n  },\n};\n<\/code><\/pre><p><a href=\"https://webpack.js.org/guides/caching/\">文档<\/a>将很好地解释这里的大部分内容，但是我将稍微解释一下需要注意的部分，因为它们花了我太多的时间。<\/p>\n<ul>\n<li>Webpack 有一些不太聪明的默认设置，比如分割输出文件时最多3个文件，最小文件大小为30 KB（所有较小的文件将连接在一起），所以我重写了这些。<\/li>\n<li><code>cacheGroups<\/code> 是我们定义 Webpack 应该如何将数据块分组到输出文件中的规则的地方。这里有一个名为 \u201cvendor\u201d 的模块，它将用于从 <code>node_modules<\/code> 加载的任何模块。通常，你只需将输出文件的名称定义为字符串。但是我将 <code>name<\/code>定义为一个函数(将为每个解析的文件调用这个函数)。然后从模块的路径返回包的名称。因此，我们将为每个包获得一个文件，例如 <code>npm.react-dom.899sadfhj4.js<\/code>。<\/li>\n<li><a href=\"https://docs.npmjs.com/files/package.json#name\">NPM 包名称必须是 URL 安全的才能发布<\/a>，因此我们不需要 <code>encodeURI<\/code> 的 <code>packageName<\/code>。 但是，我遇到一个.NET服务器不能提供名称中带有 <code>@<\/code>(来自一个限定范围的包)的文件，所以我在这个代码片段中替换了 <code>@<\/code>。<\/li>\n<li>整个设置很棒，因为它是一成不变的。 无需维护 - 不需要按名称引用任何包。<\/li>\n<\/ul>\n<p>Alice 仍然会每周重新下载 200 KB 的 <code>main.js<\/code> 文件，并且在第一次访问时仍会下载 200 KB 的npm包，但她绝不会两次下载相同的包。<\/p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-03.png\" alt><\/p>\n<p>总共： <strong>2.24 MB.<\/strong><\/p>\n<p>与基线相比减少了44%，这对于一些可以从博客文章中复制/粘贴的代码来说非常酷。<\/p>\n<p>我想知道是否有可能超过 50% ? 这完全没有问题。<\/p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具<a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug<\/a>。<\/strong><\/p>\n<h3>分离应用程序代码的区域<\/h3>\n<p>让我们转到 main.js 文件，可怜的 Alice 一次又一次地下载这个文件。<\/p>\n<p>我之前提到过，我们在此站点上有两个不同的部分：产品列表和产品详细信息页面。 每个区域中的唯一代码为25 KB（共享代码为150 KB）。<\/p>\n<p>我们的产品详情页面现在变化不大，因为我们做得太完美了。 因此，如果我们将其做为单独的文件，则可以在大多数时间从缓存中获取到它。<\/p>\n<p>另外，我们网站有一个较大的内联SVG文件用于渲染图标，重量只有25 KB，而这个也是很少变化的， 我们也需要优化它。<\/p>\n<p>我们只需手动添加一些入口点，告诉 Webpack 为每个项创建一个文件。<\/p>\n<pre class=\"prettyprint language-javascript\"><code>module.exports = {\n  entry: {\n    main: path.resolve(__dirname, &#x27;src&#x2F;index.js&#x27;),\n    ProductList: path.resolve(__dirname, &#x27;src&#x2F;ProductList&#x2F;ProductList.js&#x27;),\n    ProductPage: path.resolve(__dirname, &#x27;src&#x2F;ProductPage&#x2F;ProductPage.js&#x27;),\n    Icon: path.resolve(__dirname, &#x27;src&#x2F;Icon&#x2F;Icon.js&#x27;),\n  },\n  output: {\n    path: path.resolve(__dirname, &#x27;dist&#x27;),\n    filename: &#x27;[name].[contenthash:8].js&#x27;,\n  },\n  plugins: [\n    new webpack.HashedModuleIdsPlugin(), &#x2F;&#x2F; so that file hashes don&#x27;t change unexpectedly\n  ],\n  optimization: {\n    runtimeChunk: &#x27;single&#x27;,\n    splitChunks: {\n      chunks: &#x27;all&#x27;,\n      maxInitialRequests: Infinity,\n      minSize: 0,\n      cacheGroups: {\n        vendor: {\n          test: &#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;]&#x2F;,\n          name(module) {\n            &#x2F;&#x2F; get the name. E.g. node_modules&#x2F;packageName&#x2F;not&#x2F;this&#x2F;part.js\n            &#x2F;&#x2F; or node_modules&#x2F;packageName\n            const packageName = module.context.match(&#x2F;[\\\\&#x2F;]node_modules[\\\\&#x2F;](.*?)([\\\\&#x2F;]|$)&#x2F;)[1];\n\n            &#x2F;&#x2F; npm package names are URL-safe, but some servers don&#x27;t like @ symbols\n            return &#96;npm.${packageName.replace(&#x27;@&#x27;, &#x27;&#x27;)}&#96;;\n          },\n        },\n      },\n    },\n  },\n};\n<\/code><\/pre><p>Webpack 还会为 <code>ProductList<\/code> 和 <code>ProductPage<\/code> 之间共享的内容创建文件，这样我们就不会得到重复的代码。<\/p>\n<p>这将为 Alice 在大多数情况下节省 50 KB 的下载。<\/p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-04.png\" alt><\/p>\n<p>只有 <strong>1.815 MB!<\/strong><\/p>\n<p>我们已经为 Alice 节省了高达56％的下载量，这种节省将（在我们的理论场景中）持续到时间结束。<\/p>\n<p>所有这些都只在Webpack配置中进行了更改\u2014\u2014我们没有对应用程序代码进行任何更改。<\/p>\n<p>我在前面提到过，测试中的确切场景并不重要。这是因为，无论你提出什么场景，结论都是一样的:将应用程序分割成合理的小文件，以便用户下载更少的代码。<\/p>\n<p>很快，=将讨论\u201ccode splitting\u201d\u2014\u2014另一种类型的文件分割\u2014\u2014但首先我想解决你现在正在考虑的三个问题。<\/p>\n<p><strong>#1：大量的网络请求不是更慢吗?<\/strong><\/p>\n<p>答案当然是<strong>不会<\/strong>。<\/p>\n<p>在 HTTP/1.1 时代，这曾经是一种情况，但在 HTTP/2 时代就不是这样了。<\/p>\n<p>尽管如此，<a href=\"https://medium.com/%5B@asyncmax%5D(/user/asyncmax)/the-right-way-to-bundle-your-assets-for-faster-sites-over-http-2-437c37efe3ff\">这篇2016年的文章<\/a> 和 <a href=\"http://engineering.khanacademy.org/posts/js-packaging-http2.htm\">Khan Academy 2015年的文章<\/a>都得出结论，即使使用 HTTP/2，下载太多的文件还是比较慢。但在这两篇文章中，\u201c太多\u201d的意思都是\u201c几百个\u201d。所以请记住，如果你有数百个文件，你可能一开始就会遇到并发限制。<\/p>\n<p>如果您想知道，对 HTTP/2 的支持可以追溯到 Windows 10 上的 ie11。我做了一个详尽的调查，每个人都使用比那更旧的设置，他们一致向我保证，他们不在乎网站加载有多快。<\/p>\n<p><strong>#2:每个webpack包中没有 开销/引用 代码吗?<\/strong><\/p>\n<p>是的，这也是真的。<\/p>\n<p>好吧,狗屎:<\/p>\n<ul>\n<li>more files = 更多 Webpack 引用<\/li>\n<li>more files = 不压缩<\/li>\n<\/ul>\n<p>让我们量化一下，这样我们就能确切地知道需要担心多少。<\/p>\n<p>好的，我刚做了一个测试，一个 190 KB 的站点拆分成 19 个文件，增加了大约 2％发送到浏览器的总字节数。<\/p>\n<p>因此\u2026在第一次访问时增加 2％，在每次访问之前减少60％直到网站下架。<\/p>\n<p>正确的担忧是:完全没有。<\/p>\n<p>当我测试1个文件对19个时，我想我会在一些不同的网络上试一试，包括HTTP / 1.1<\/p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-05.png\" alt><\/p>\n<p>在 3G 和4G上，这个站点在有19个文件的情况下加载时间减少了30%。<\/p>\n<p>这是非常杂乱的数据。 例如，在运行2号 的 4G 上，站点加载时间为 646ms，然后运行两次之后，加载时间为1116ms，比之前长73%，没有变化。因此，声称 HTTP/2 \u201c快30%\u201d 似乎有点鬼鬼祟祟。<\/p>\n<p>我创建这个表是为了尝试量化 HTTP/2 所带来的差异，但实际上我唯一能说的是\u201c它可能没有显著的差异\u201d。<\/p>\n<p>真正令人吃惊的是最后两行。那是旧的 Windows 和 HTTP/1.1，我打赌会慢得多,我想我需把网速调慢一点。<\/p>\n<p>我从微软的网站上下载了一个Windows 7 虚拟机来测试这些东西。它是 IE8 自带的，我想把它升级到IE9，所以我转到微软的IE9下载页面\u2026<\/p>\n<p><img src=\"https://image.fundebug.com/2019-03-03-06.png\" alt=\"06\">关于HTTP/2 的最后一个问题，你知道它现在已经内置到 Node中了吗?如果你想体验一下，我编写了<a href=\"https://gist.github.com/davidgilbertson/e5690c04e06c4882cf5761f8acff36ec\">一个带有gzip、brotli和响应缓存的小型100行HTTP/2服务器<\/a>点击预览，以满足你的测试乐趣。<\/p>\n<p>这就是我要讲的关于 bundle splitting 的所有内容。我认为这种方法唯一的缺点是必须不断地说服人们加载大量的小文件是可以的。<\/p>\n<h3>Code splitting (加载你需要的代码)<\/h3>\n<p>我说，这种特殊的方法只有在某些网站上才有意义。<\/p>\n<p>我喜欢应用我刚刚编造的 20/20 规则:如果你的站点的某个部分只有 20% 的用户访问，并且它大于站点的 JavaScript 的 20%，那么你应该按需加载该代码。<\/p>\n<h4>如何决定?<\/h4>\n<p>假设你有一个购物网站，想知道是否应该将\u201ccheckout\u201d的代码分开，因为只有30%的访问者才会访问那里。<\/p>\n<p>首先要做的是卖更好的东西。<\/p>\n<p>第二件事是弄清楚多少代码对于结账功能是完全独立的。 由于在执行\u201ccode splitting\u201d 之前应始终先\u201cbundle splitting\u2019 \u201d，因此你可能已经知道代码的这一部分有多大。<\/p>\n<p>它可能比你想象的要小，所以在你太兴奋之前做一下加法。例如，如果你有一个 React 站点，那么你的 <code>store<\/code>、<code>reducer<\/code>、<code>routing<\/code>、<code>actions<\/code> 等都将在整个站点上共享。唯一的部分将主要是组件和它们的帮助类。<\/p>\n<p>因此，你注意到你的结帐页面完全独特的代码是 <code>7KB<\/code>。 该网站的其余部分是 <code>300 KB<\/code>。 我会看着这个，然后说，我不打算把它拆分，原因如下:<\/p>\n<ul>\n<li>\n<p>提前加载不会变慢。记住，你是在并行加载所有这些文件。查看是否可以记录 <code>300KB<\/code> 和 <code>307KB<\/code> 之间的加载时间差异。<\/p>\n<\/li>\n<li>\n<p>如果你稍后加载此代码，则用户必须在单击\u201cTAKE MY MONEY\u201d之后等待该文件 - 你希望延迟的最小的时间。<\/p>\n<\/li>\n<li>\n<p>Code splitting 需要更改应用程序代码。 它引入了异步逻辑，以前只有同步逻辑。 这不是火箭科学，但我认为应该通过可感知的用户体验改进来证明其复杂性。<\/p>\n<\/li>\n<\/ul>\n<p>让我们看两个 code splitting 的例子。<\/p>\n<h3>Polyfills<\/h3>\n<p>我将从这个开始，因为它适用于大多数站点，并且是一个很好的简单介绍。<\/p>\n<p>我在我的网站上使用了一些奇特的功能，所以我有一个文件可以导入我需要的所有polyfill， 它包括以下八行：<\/p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; polyfills.js \nrequire(&#x27;whatwg-fetch&#x27;);\nrequire(&#x27;intl&#x27;);\nrequire(&#x27;url-polyfill&#x27;);\nrequire(&#x27;core-js&#x2F;web&#x2F;dom-collections&#x27;);\nrequire(&#x27;core-js&#x2F;es6&#x2F;map&#x27;);\nrequire(&#x27;core-js&#x2F;es6&#x2F;string&#x27;);\nrequire(&#x27;core-js&#x2F;es6&#x2F;array&#x27;);\nrequire(&#x27;core-js&#x2F;es6&#x2F;object&#x27;);\n<\/code><\/pre><p>在 <code>index.js<\/code> 中导入这个文件。<\/p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; index-always-poly.js\nimport &#x27;.&#x2F;polyfills&#x27;;\nimport React from &#x27;react&#x27;;\nimport ReactDOM from &#x27;react-dom&#x27;;\nimport App from &#x27;.&#x2F;App&#x2F;App&#x27;;\nimport &#x27;.&#x2F;index.css&#x27;;\n\nconst render = () =&gt; {\n  ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#x27;root&#x27;));\n}\n\nrender(); &#x2F;&#x2F; yes I am pointless, for now\n<\/code><\/pre><p>使用 bundle splitting 的 Webpack 配置，我的 polyfills 将自动拆分为四个不同的文件，因为这里有四个 npm 包。 它们总共大约 25 KB，并且 90％ 的浏览器不需要它们，因此值得动态加载它们。<\/p>\n<p>使用 Webpack 4 和 <code>import()<\/code> 语法（不要与 <code>import<\/code> 语法混淆），有条件地加载polyfill 非常容易。<\/p>\n<pre class=\"prettyprint language-javascript\"><code>import React from &#x27;react&#x27;;\nimport ReactDOM from &#x27;react-dom&#x27;;\nimport App from &#x27;.&#x2F;App&#x2F;App&#x27;;\nimport &#x27;.&#x2F;index.css&#x27;;\n\nconst render = () =&gt; {\n  ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#x27;root&#x27;));\n}\n\nif (\n  &#x27;fetch&#x27; in window &amp;&amp;\n  &#x27;Intl&#x27; in window &amp;&amp;\n  &#x27;URL&#x27; in window &amp;&amp;\n  &#x27;Map&#x27; in window &amp;&amp;\n  &#x27;forEach&#x27; in NodeList.prototype &amp;&amp;\n  &#x27;startsWith&#x27; in String.prototype &amp;&amp;\n  &#x27;endsWith&#x27; in String.prototype &amp;&amp;\n  &#x27;includes&#x27; in String.prototype &amp;&amp;\n  &#x27;includes&#x27; in Array.prototype &amp;&amp;\n  &#x27;assign&#x27; in Object &amp;&amp;\n  &#x27;entries&#x27; in Object &amp;&amp;\n  &#x27;keys&#x27; in Object\n) {\n  render();\n} else {\n  import(&#x27;.&#x2F;polyfills&#x27;).then(render);\n}\n<\/code><\/pre><p>合理？ 如果支持所有这些内容，则渲染页面。 否则，导入 polyfill 然后渲染页面。 当这个代码在浏览器中运行时，Webpack 的运行时将处理这四个 npm 包的加载，当它们被下载和解析时，将调用 <code>render()<\/code> 并继续进行。<\/p>\n<p>顺便说一句，要使用 <code>import()<\/code>，你需要 <a href=\"https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import/\">Babel 的动态导入插件<\/a>。另外，正如 Webpack 文档解释的那样，<a href=\"https://webpack.js.org/guides/code-splitting/#dynamic-imports\">import() 使用 promises<\/a>，所以你需要将其与其他polyfill分开填充。<\/p>\n<h3>基于路由的动态加载（特定于React）<\/h3>\n<p>回到 Alice 的例子，假设站点现在有一个\u201c管理\u201d部分，产品的销售者可以登录并管理他们所销售的一些没用的记录。<\/p>\n<p>本节有许多精彩的特性、大量的图表和来自 npm 的大型图表库。因为我已经在做 bundle splittin 了，我可以看到这些都是超过 100 KB 的阴影。<\/p>\n<p>目前，我有一个路由设置，当用户查看 <code>/admin<\/code> URL时，它将渲染 <code>&lt;AdminPage&gt;<\/code>。当Webpack 打包所有东西时，它会找到 <code>import AdminPage from './AdminPage.js'<\/code>。然后说&quot;嘿，我需要在初始负载中包含这个&quot;<\/p>\n<p>但我们不希望这样，我们需要将这个引用放到一个动态导入的管理页面中，比如<code>import('./AdminPage.js')<\/code> ，这样 Webpack 就知道动态加载它。<\/p>\n<p>它非常酷，不需要配置。<\/p>\n<p>因此，不必直接引用 <code>AdminPage<\/code>，我可以创建另一个组件，当用户访问 <code>/admin<\/code> URL时将渲染该组件，它可能是这样的:<\/p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; AdminPageLoader.js \nimport React from &#x27;react&#x27;;\n\nclass AdminPageLoader extends React.PureComponent {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      AdminPage: null,\n    }\n  }\n\n  componentDidMount() {\n    import(&#x27;.&#x2F;AdminPage&#x27;).then(module =&gt; {\n      this.setState({ AdminPage: module.default });\n    });\n  }\n\n  render() {\n    const { AdminPage } = this.state;\n\n    return AdminPage\n      ? &lt;AdminPage {...this.props} &#x2F;&gt;\n      : &lt;div&gt;Loading...&lt;&#x2F;div&gt;;\n  }\n}\n\nexport default AdminPageLoader;\n<\/code><\/pre><p>这个概念很简单，对吧? 当这个组件挂载时(意味着用户位于 <code>/admin<\/code> URL)，我们将动态加载 <code>./AdminPage.js<\/code>，然后在状态中保存对该组件的引用。<\/p>\n<p>在 <code>render<\/code> 方法中，我们只是在等待 <code>&lt;AdminPage&gt;<\/code> 加载时渲染 <code>&lt;div&gt;Loading...&lt;/div&gt;<\/code>，或者在加载并存储状态时渲染 <code>&lt;AdminPage&gt;<\/code>。<\/p>\n<p>我想自己做这个只是为了好玩，但是在现实世界中，你只需要使用 <code>react-loadable<\/code> ，如关于 <a href=\"https://reactjs.org/docs/code-splitting.html\">code-splitting 的React文档<\/a>中所述。<\/p>\n<h3>总结<\/h3>\n<p>对于上面总结以下两点：<\/p>\n<ul>\n<li>如果有人不止一次访问你的网站，把你的代码分成许多小文件。<\/li>\n<li>如果你的站点有大部分用户不访问的部分，则动态加载该代码。<\/li>\n<\/ul>\n<p><strong>原文：<\/strong> <a href=\"https://hackernoon.com/the-100-correct-way-to-split-your-chunks-with-webpack-f8a9df5b7758\">The 100% correct way to split your chunks with Webpack<\/a><\/p>\n<h3>关于Fundebug<\/h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug<\/a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用<\/a>！<\/p>\n<\/div>","title":"Web 性能优化： 使用 Webpack 分离数据的正确方法","last_reply_at":"2019-03-04T07:33:57.097Z","good":true,"top":false,"reply_count":1,"visit_count":454,"create_at":"2019-03-04T02:18:36.451Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5671441a1d2912ce2a35aaa1","author_id":"530ed7b25adfcd9c0f0713b6","tab":"share","content":"<div class=\"markdown-text\"><p>也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。\n下面，给分享一下各种「登录」相关的需求<\/p>\n<h2>普通的登录<\/h2>\n<p>这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。\n这种登录，在上学的时候，也许敬爱的老师就已经教过你了。\n但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。<\/p>\n<p><strong>密码Hash<\/strong>\n密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用<a href=\"https://www.npmjs.com/package/bcryptjs\">bcryptjs<\/a>，它提供了<code>hash<\/code>以及对应的<code>compare<\/code>方法，非常适合用于密码的加密和对比。<\/p>\n<p><strong>Session原理<\/strong>\nSession的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。\n欲知更多有关「Session原理」请点击传送门：<a href=\"http://www.jianshu.com/p/2b7c10291aad\">Session原理<\/a><\/p>\n<h2>使用独立登录系统<\/h2>\n<p>应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 <code>www.site.com<\/code>，一个则是<code>passport.site.com<\/code>了。要在不同的域名下进行登录，一般的方法是<code>www.site.com/login<\/code> 跳转到 <code>passport.site.com/login<\/code>，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到<code>www.site.com<\/code>提供的回调处理地址，然后进行解密，匹配正确，则登录用户。\n要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。<\/p>\n<h2>单点登录<\/h2>\n<p>单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。\n这又分两种情况，A站点和B站点是否在同一个二级域名下。\n假如是在同一个域名下，例如<code>siteA.site.com<\/code>与<code>siteB.site.com<\/code>，因为cookie允许设置到二级域名下<code>.site.com<\/code>，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置<code>http only<\/code>，就可以一站登录，站站登录。\n而如果A站点和B站点不在同一二级域名下，例如<code>www.siteA.com<\/code>与<code>www.siteB.com<\/code>，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。\n欲知更多有关「单点登录」请点击传送门：<a href=\"http://www.jianshu.com/p/613e44d4a464\">单点登录的三种实现方式<\/a><\/p>\n<h2>OAuth2.0登录<\/h2>\n<p>这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、<em>@^<\/em>&amp;@%#^%^@%&amp;%@&amp;#\u2026\n这些统一叫做：「第三方登录」。\n第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：\n第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫<code>access_token<\/code>，获取之后就把这个<code>access_token<\/code>存到数据库中，请求一些第三方提供的API，需要用到这个<code>access_token<\/code>，因为这个token就是记录用户在第三方系统的一个身份凭证。\n一些系统，在获取<code>access_token<\/code>的时候，还会返回一个副参数<code>refresh_token<\/code>，因为<code>access_token<\/code>是有过期时间的，一旦过期了，主站可以使用<code>refresh_token<\/code>请求第三方提供的接口获取新的<code>access_token<\/code>以及新的<code>refresh_token<\/code>。\n在Nodejs中，你可以使用<code>passport<\/code>来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了<a href=\"https://www.npmjs.com/package/passport\">passport<\/a>，也可以使用<a href=\"https://www.npmjs.com/package/wechat-oauth\">wechat-oauth<\/a><\/p>\n<h2>在最后<\/h2>\n<p>其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。\nsha1加密，可以使用Nodejs自带的<code>crypto<\/code>，JWT可以使用<a href>jsonwebtoken<\/a><\/p>\n<hr>\n<p>如果本文对您有用\n请不要吝啬你们的Follow与Start\n这会大大支持我们继续创作<\/p>\n<p><strong>「Github」<\/strong>\nMZMonster ：<a href=\"https://github.com/MZMonster/\">@MZMonster<\/a>\nJC_Huang ：<a href=\"https://github.com/JerryC8080\">@JerryC8080<\/a><\/p>\n<p><strong>「简书」<\/strong>\nMZMonster：<a href=\"http://www.jianshu.com/collection/2a4335808d4c\">@MZMonster<\/a>\nJC_Huang：<a href=\"http://www.jianshu.com/users/843d2366f95b/latest_articles\">@JC_Huang<\/a><\/p>\n<\/div>","title":"登录那些事儿","last_reply_at":"2019-02-22T03:48:45.670Z","good":true,"top":false,"reply_count":42,"visit_count":28804,"create_at":"2015-12-16T10:59:38.333Z","author":{"loginname":"JerryC8080","avatar_url":"https://avatars0.githubusercontent.com/u/6801672?v=4&s=120"}},{"id":"5203a71844e76d216a727d2e","author_id":"5167d7b96d38277306098b54","tab":"share","content":"<div class=\"markdown-text\"><p>所谓工欲善其事，必先利其器，所以通读了<a href=\"https://npmjs.org/package/cheerio\">cheerio<\/a>的API，顺便翻译了一遍，有些地方因为知道的比较少，不知道什么意思，保留了英文，希望各位不吝告诉我，然后一起把这个翻译完成。<\/p>\n<p>###cheerio\n为服务器特别定制的，快速、灵活、实施的jQuery核心实现.\n###Introduction\n将HTML告诉你的服务器<\/p>\n<pre class=\"prettyprint\"><code>var cheerio = require(&#x27;cheerio&#x27;),\n    $ = cheerio.load(&#x27;&lt;h2 class=&quot;title&quot;&gt;Hello world&lt;&#x2F;h2&gt;&#x27;);\n\n$(&#x27;h2.title&#x27;).text(&#x27;Hello there!&#x27;);\n$(&#x27;h2&#x27;).addClass(&#x27;welcome&#x27;);\n\n$.html();\n&#x2F;&#x2F;=&gt; &lt;h2 class=&quot;title welcome&quot;&gt;Hello there!&lt;&#x2F;h2&gt;\n<\/code><\/pre><p>###Installation\nnpm install cheerio<\/p>\n<p>###Features\n**❤ 相似的语法:**Cheerio 包括了 jQuery 核心的子集。Cheerio  从jQuery库中去除了所有 DOM不一致性和浏览器尴尬的部分，揭示了它真正优雅的API。<\/p>\n<p>**ϟ 闪电般的块:**Cheerio 工作在一个非常简单，一致的DOM模型之上。解析，操作，呈送都变得难以置信的高效。基础的端到端的基准测试显示Cheerio 大约比JSDOM快八倍(8x)。<\/p>\n<p><strong>❁ 巨灵活:<\/strong> Cheerio 封装了兼容的htmlparser。Cheerio 几乎能够解析任何的 HTML 和 XML document。<\/p>\n<p>###What about JSDOM\n我写cheerio 是因为我发现我自己对JSDOM越来越沮丧。对于我来说，总是会一次又一次的碰上几个难点。<\/p>\n<ul>\n<li>\n<p><strong>JSDOM内建的解析太过于严格<\/strong>: JSDOM附带的HTML解析不能处理很多当下的大众的网站。<\/p>\n<\/li>\n<li>\n<p><strong>JSDOM太慢<\/strong>:用JSDOM解析大型网站存在可见的延迟。<\/p>\n<\/li>\n<li>\n<p><strong>JSDOM太累赘<\/strong>:JSDOM的目标是提供一个我们在浏览器里面看到的相同的 DOM 环境。我从没有真的需要所有这些东西，我只是想要一个简单的，相似的方法去处理HTML。<\/p>\n<\/li>\n<\/ul>\n<p>###When I would use JSDOM\nCheerio 不会解决你的所有问题。我人会使用JSDOM如果我需要用一个在服务器上的浏览器环境，特别是如果我想要自动化一些功能测试。\n###API\n####我们将用到的标记示例\n&lt;ul id=\u201cfruits\u201d&gt;\n&lt;li class=\u201capple\u201d&gt;Apple&lt;/li&gt;\n&lt;li class=\u201corange\u201d&gt;Orange&lt;/li&gt;\n&lt;li class=\u201cpear\u201d&gt;Pear&lt;/li&gt;\n&lt;/ul&gt;<\/p>\n<p>这是我们将会在所有的API例子中用到的HTML标记<\/p>\n<p>####Loading\n首先你需要加载HTML。这一步对jQuery来说是必须的，since jQuery operates on the one, baked-in DOM。通过Cheerio,我们需要把HTML document 传进去。<\/p>\n<p>这是<strong>首选<\/strong>:<\/p>\n<pre class=\"prettyprint\"><code>var cheerio = require(&#x27;cheerio&#x27;),\n    $ = cheerio.load(&#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;);\n<\/code><\/pre><p>或者通过传递字符串作为内容来加载HTML:<\/p>\n<pre class=\"prettyprint\"><code>$ = require(&#x27;cheerio&#x27;);\n$(&#x27;ul&#x27;, &#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;);\n<\/code><\/pre><p>Or as the root:<\/p>\n<pre class=\"prettyprint\"><code>$ = require(&#x27;cheerio&#x27;);\n$(&#x27;li&#x27;, &#x27;ul&#x27;, &#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;);\n<\/code><\/pre><p>你也可以传递一个额外的对象给.load()如果你需要更改任何的默认解析选项的话:<\/p>\n<pre class=\"prettyprint\"><code>$ = cheerio.load(&#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;, {\n    ignoreWhitespace: true,\n    xmlMode: true\n});\n<\/code><\/pre><p>这些解析选项都是直接来自htmlparser ，因此任何在htmlparser里有效的选项在Chreeio里也是行得通的。默认的选项如下:<\/p>\n<pre class=\"prettyprint\"><code>{\n    ignoreWhitespace: false,\n    xmlMode: false,\n    lowerCaseTags: false\n}\n<\/code><\/pre><p>想看选项清单和它们都效果，看\n<a href=\"https://github.com/fb55/DomHandler\">这个<\/a>和\n<a href=\"https://github.com/fb55/htmlparser2/wiki/Parser-options\">这个<\/a><\/p>\n<p>####Selectors<\/p>\n<p>Cheerio的选择器用起来几乎和jQuery一样，所以API也很相似。<\/p>\n<p><strong>$(selectior,[context],[root])<\/strong><\/p>\n<p>选择器在 Context 范围内搜索，Context又在Root范围内搜索。selector 和context可是是一个字符串表达式，DOM元素，和DOM元素的数组，或者chreeio对象。root 是通常是HTML 文档字符串。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;, &#x27;#fruits&#x27;).text()\n&#x2F;&#x2F;=&gt; Apple\n\n$(&#x27;ul .pear&#x27;).attr(&#x27;class&#x27;)\n&#x2F;&#x2F;=&gt; pear\n\n$(&#x27;li[class=orange]&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n<\/code><\/pre><p>####Attributes\n获得和修改属性<\/p>\n<p><strong>.attr(name,value)<\/strong><\/p>\n<p>获得和修改属性。在匹配的元素中只能获得第一元素的属性。如果设置一个属性的值为null，则移除这个属性。你也可以传递一对键值，或者一个函数。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).attr(&#x27;id&#x27;)\n&#x2F;&#x2F;=&gt; fruits\n\n$(&#x27;.apple&#x27;).attr(&#x27;id&#x27;, &#x27;favorite&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;apple&quot; id=&quot;favorite&quot;&gt;Apple&lt;&#x2F;li&gt;\n<\/code><\/pre><p>更多信息请看<a href=\"http://api.jquery.com/attr/\">这里<\/a><\/p>\n<p><strong>value([value])<\/strong><\/p>\n<p>获得和修改input,select,textarea的value.注意: 对于传递键值和函数的支持还没有被加进去。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;input[type=&quot;text&quot;]&#x27;).val()\n=&gt; input_text\n\n$(&#x27;input[type=&quot;text&quot;]&#x27;).val(&#x27;test&#x27;).html()\n=&gt; &lt;input type=&quot;text&quot; value=&quot;test&quot;&#x2F;&gt;\n<\/code><\/pre><p><strong>.removeAttr(name)<\/strong><\/p>\n<p>通过name删除属性<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).removeAttr(&#x27;class&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li&gt;Pear&lt;&#x2F;li&gt;\n<\/code><\/pre><p><strong>.hasClass( className )<\/strong><\/p>\n<p>检查匹配的元素是否有给出的类名<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).hasClass(&#x27;pear&#x27;)\n&#x2F;&#x2F;=&gt; true\n\n$(&#x27;apple&#x27;).hasClass(&#x27;fruit&#x27;)\n&#x2F;&#x2F;=&gt; false\n\n$(&#x27;li&#x27;).hasClass(&#x27;pear&#x27;)\n&#x2F;&#x2F;=&gt; true\n<\/code><\/pre><p><strong>.addClass(className)<\/strong><\/p>\n<p>增加class(es)给所有匹配的elements.也可以传函数。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).addClass(&#x27;fruit&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;pear fruit&quot;&gt;Pear&lt;&#x2F;li&gt;\n\n$(&#x27;.apple&#x27;).addClass(&#x27;fruit red&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;apple fruit red&quot;&gt;Apple&lt;&#x2F;li&gt;\n<\/code><\/pre><p>更多信息看<a href=\"http://api.jquery.com/addClass/\">这里<\/a><\/p>\n<p><strong>.removeClass([className])<\/strong><\/p>\n<p>从选择的elements里去除一个或多个有空格分开的class。如果className 没有定义，所有的classes将会被去除，也可以传函数。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).removeClass(&#x27;pear&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;&quot;&gt;Pear&lt;&#x2F;li&gt;\n\n$(&#x27;.apple&#x27;).addClass(&#x27;red&#x27;).removeClass().html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;&quot;&gt;Apple&lt;&#x2F;li&gt;\n<\/code><\/pre><p>更多信息看<a href=\"http://api.jquery.com/removeClass/\">这里<\/a><\/p>\n<p><strong>.is.(selector)<\/strong><\/p>\n<p><strong>.is(function(index))<\/strong><\/p>\n<p>有任何元素匹配selector就返回true。如果使用判定函数，判定函数在选中的元素中执行，所以this指向当前的元素。<\/p>\n<p>####Traversing<\/p>\n<p><strong>.find(selector)<\/strong><\/p>\n<p>获得一个在匹配的元素中由选择器滤过的后代。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).find(&#x27;li&#x27;).length\n&#x2F;&#x2F;=&gt; 3\n<\/code><\/pre><p><strong>.parent([selector])<\/strong><\/p>\n<p>获得每个匹配元素的parent,可选择性的通过selector筛选。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).parent().attr(&#x27;id&#x27;)\n&#x2F;&#x2F;=&gt; fruits\n<\/code><\/pre><p><strong>.parents([selector])<\/strong><\/p>\n<p>获得通过选择器筛选匹配的元素的parent集合。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).parents().length\n&#x2F;&#x2F; =&gt; 2\n$(&#x27;.orange&#x27;).parents(&#x27;#fruits&#x27;).length\n&#x2F;&#x2F; =&gt; 1\n<\/code><\/pre><p><strong>.closest([selector])<\/strong><\/p>\n<p>对于每个集合内的元素，通过测试这个元素和DOM层级关系上的祖先元素，获得第一个匹配的元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).closest()\n&#x2F;&#x2F; =&gt; []\n$(&#x27;.orange&#x27;).closest(&#x27;.apple&#x27;)\n&#x2F;&#x2F; =&gt; []\n$(&#x27;.orange&#x27;).closest(&#x27;li&#x27;)\n&#x2F;&#x2F; =&gt; [&lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;]\n$(&#x27;.orange&#x27;).closest(&#x27;#fruits&#x27;)\n&#x2F;&#x2F; =&gt; [&lt;ul id=&quot;fruits&quot;&gt; ... &lt;&#x2F;ul&gt;]\n<\/code><\/pre><p><strong>.next()<\/strong>\n获得第一个本元素之后的同级元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).next().hasClass(&#x27;orange&#x27;)\n&#x2F;&#x2F;=&gt; true\n<\/code><\/pre><p><strong>.nextAll()<\/strong><\/p>\n<p>获得本元素之后的所有同级元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).nextAll()\n&#x2F;&#x2F;=&gt; [&lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;, &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;]\n<\/code><\/pre><p><strong>.prev()<\/strong><\/p>\n<p>获得本元素之前的第一个同级元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).prev().hasClass(&#x27;apple&#x27;)\n&#x2F;&#x2F;=&gt; true\n<\/code><\/pre><p><strong>.preAll()<\/strong><\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).prevAll()\n&#x2F;&#x2F;=&gt; [&lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;, &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;]\n<\/code><\/pre><p>获得本元素前的所有同级元素<\/p>\n<p><strong>.slice(start,[end])<\/strong><\/p>\n<p>获得选定范围内的元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).slice(1).eq(0).text()\n&#x2F;&#x2F;=&gt; &#x27;Orange&#x27;\n\n$(&#x27;li&#x27;).slice(1, 2).length\n&#x2F;&#x2F;=&gt; 1\n<\/code><\/pre><p><strong>.siblings(selector)<\/strong><\/p>\n<p>获得被选择的同级元素，除去自己??<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).siblings().length\n&#x2F;&#x2F;=&gt; 2\n\n$(&#x27;.pear&#x27;).siblings(&#x27;.orange&#x27;).length\n&#x2F;&#x2F;=&gt; 1\n<\/code><\/pre><p><strong>.children(selector)<\/strong><\/p>\n<p>获被选择元素的子元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).children().length\n&#x2F;&#x2F;=&gt; 3\n\n$(&#x27;#fruits&#x27;).children(&#x27;.pear&#x27;).text()\n&#x2F;&#x2F;=&gt; Pear\n<\/code><\/pre><p><strong>.each(function(index,element))<\/strong><\/p>\n<p>迭代一个cheerio对象，为每个匹配元素执行一个函数。When the callback is fired, the function is fired in the context of the DOM element, so this refers to the current element, which is equivalent to the function parameter element.要提早跳出循环，返回false.<\/p>\n<pre class=\"prettyprint\"><code>var fruits = [];\n\n$(&#x27;li&#x27;).each(function(i, elem) {\n  fruits[i] = $(this).text();\n});\n\nfruits.join(&#x27;, &#x27;);\n&#x2F;&#x2F;=&gt; Apple, Orange, Pear\n<\/code><\/pre><p><strong>.map(function(index,element))<\/strong><\/p>\n<p>迭代一个cheerio对象，为每个匹配元素执行一个函数。Map会返回一个迭代结果的数组。the function is fired in the context of the DOM element, so this refers to the current element, which is equivalent to the function parameter element<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).map(function(i, el) {\n  &#x2F;&#x2F; this === el\n  return $(this).attr(&#x27;class&#x27;);\n}).join(&#x27;, &#x27;);\n&#x2F;&#x2F;=&gt; apple, orange, pear\n<\/code><\/pre><p><strong>.filter(selector)<\/strong><\/p>\n<p><strong>.filter(function(index))<\/strong><\/p>\n<p>迭代一个cheerio对象，滤出匹配选择器或者是传进去的函数的元素。如果使用函数方法，这个函数在被选择的元素中执行，所以this指向的手势当前元素。<\/p>\n<p>Selector:<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).filter(&#x27;.orange&#x27;).attr(&#x27;class&#x27;);\n&#x2F;&#x2F;=&gt; orange\n<\/code><\/pre><p>Function:<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).filter(function(i, el) {\n  &#x2F;&#x2F; this === el\n  return $(this).attr(&#x27;class&#x27;) === &#x27;orange&#x27;;\n}).attr(&#x27;class&#x27;)\n&#x2F;&#x2F;=&gt; orange\n<\/code><\/pre><p><strong>.first()<\/strong><\/p>\n<p>会选择chreeio对象的第一个元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).children().first().text()\n&#x2F;&#x2F;=&gt; Apple\n<\/code><\/pre><p><strong>.last()<\/strong><\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).children().last().text()\n&#x2F;&#x2F;=&gt; Pear\n<\/code><\/pre><p>会选择chreeio对象的最后一个元素<\/p>\n<p><strong>.eq(i)<\/strong><\/p>\n<p>通过索引筛选匹配的元素。使用.eq(-i)就从最后一个元素向前数。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).eq(0).text()\n&#x2F;&#x2F;=&gt; Apple\n\n$(&#x27;li&#x27;).eq(-1).text()\n&#x2F;&#x2F;=&gt; Pear\n<\/code><\/pre><p>###Manipulation<\/p>\n<p>改变DOM结构的方法<\/p>\n<p><strong>.append(content,[content\u2026])<\/strong><\/p>\n<p>在每个元素最后插入一个子元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).append(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n<\/code><\/pre><p><strong>.prepend(content,[content,\u2026])<\/strong><\/p>\n<p>在每个元素最前插入一个子元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).prepend(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n<\/code><\/pre><p><strong>.after(content,[content,\u2026])<\/strong><\/p>\n<p>在每个匹配元素之后插入一个元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).after(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n<\/code><\/pre><p><strong>.before(content,[content,\u2026])<\/strong><\/p>\n<p>在每个匹配的元素之前插入一个元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).before(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n<\/code><\/pre><p><strong>.remove( [selector] )<\/strong><\/p>\n<p>从DOM中去除匹配的元素和它们的子元素。选择器用来筛选要删除的元素。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).remove()\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n<\/code><\/pre><p><strong>.replaceWith( content )<\/strong><\/p>\n<p>替换匹配的的元素<\/p>\n<pre class=\"prettyprint\"><code>var plum = $(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$(&#x27;.pear&#x27;).replaceWith(plum)\n$.html()\n&#x2F;&#x2F;=&gt; &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;     &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;     &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;     &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;   &lt;&#x2F;ul&gt;\n<\/code><\/pre><p><strong>.empty()<\/strong><\/p>\n<p>清空一个元素，移除所有的子元素<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).empty()\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;&lt;&#x2F;ul&gt;\n<\/code><\/pre><p><strong>.html( [htmlString] )<\/strong><\/p>\n<p>获得元素的HTML字符串。如果htmlString有内容的话，将会替代原来的HTML<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).html()\n&#x2F;&#x2F;=&gt; Orange\n\n$(&#x27;#fruits&#x27;).html(&#x27;&lt;li class=&quot;mango&quot;&gt;Mango&lt;&#x2F;li&gt;&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;mango&quot;&gt;Mango&lt;&#x2F;li&gt;\n<\/code><\/pre><p><strong>.text( [textString] )<\/strong><\/p>\n<p>获得元素的text内容，包括子元素。如果textString被指定的话，每个元素的text内容都会被替换。<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).text()\n&#x2F;&#x2F;=&gt; Orange\n\n$(&#x27;ul&#x27;).text()\n&#x2F;&#x2F;=&gt;  Apple\n&#x2F;&#x2F;    Orange\n&#x2F;&#x2F;    Pear\n<\/code><\/pre><p>###Rendering<\/p>\n<p>如果你想呈送document，你能使用html多效用函数。<\/p>\n<pre class=\"prettyprint\"><code>$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n<\/code><\/pre><p>如果你想呈送outerHTML,你可以使用 $.html(selector)<\/p>\n<pre class=\"prettyprint\"><code>$.html(&#x27;.pear&#x27;)\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n<\/code><\/pre><p>默认的,html会让一些标签保持开标签的状态.有时候你想呈现一个有效的XML文档.例如下面这个:<\/p>\n<pre class=\"prettyprint\"><code>$ = cheerio.load(&#x27;&lt;media:thumbnail url=&quot;http:&#x2F;&#x2F;www.foo.com&#x2F;keyframe.jpg&quot; width=&quot;75&quot; height=&quot;50&quot; time=&quot;12:05:01.123&quot;&#x2F;&gt;&#x27;);\n<\/code><\/pre><p>然后为了呈现这个XML,你需要使用<code>xml<\/code>这个函数:<\/p>\n<pre class=\"prettyprint\"><code>$.xml()\n&#x2F;&#x2F;=&gt;  &lt;media:thumbnail url=&quot;http:&#x2F;&#x2F;www.foo.com&#x2F;keyframe.jpg&quot; width=&quot;75&quot; height=&quot;50&quot; time=&quot;12:05:01.123&quot;&#x2F;&gt;\n<\/code><\/pre><p>###Miscellaneous<\/p>\n<p>不属于其它地方的DOM 元素方法<\/p>\n<p><strong>.toArray()<\/strong><\/p>\n<p>取得所有的在DOM元素，转化为数组、<\/p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).toArray()\n&#x2F;&#x2F;=&gt; [ {...}, {...}, {...} ]\n<\/code><\/pre><p><strong>.clone()<\/strong><\/p>\n<p>克隆cheerio对象<\/p>\n<pre class=\"prettyprint\"><code>var moreFruit = $(&#x27;#fruits&#x27;).clone()\n<\/code><\/pre><p>###Utilities<\/p>\n<p><strong>$.root<\/strong>\n有时候你想找到最上层的root元素,那么<code>$.root()<\/code>就能获得:<\/p>\n<pre class=\"prettyprint\"><code>$.root().append(&#x27;&lt;ul id=&quot;vegetables&quot;&gt;&lt;&#x2F;ul&gt;&#x27;).html();\n&#x2F;&#x2F;=&gt; &lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&lt;ul id=&quot;vegetables&quot;&gt;&lt;&#x2F;ul&gt;\n<\/code><\/pre><p><strong>$.contains( container, contained )<\/strong><\/p>\n<p>查看cotained元素是否是container元素的子元素<\/p>\n<p><strong>$.parseHTML( data [, context ] [, keepScripts ] )<\/strong><\/p>\n<p>将字符串解析为DOM节点数组。context参数对chreeio没有意义，但是用来维护APi的兼容性。<\/p>\n<p>###Screencasts<\/p>\n<p><a href=\"http://vimeo.com/31950192\">http://vimeo.com/31950192<\/a><\/p>\n<p>这个视频教程是follow-up Nettut的&quot;How to Scrape Web Pages with Node.js and jQuery&quot;，用 cheerio而不是JSDOM+JQuery. 这个视频就是展示chreeio多牛B，多快的。<\/p>\n<\/div>","title":"通读cheerio API","last_reply_at":"2019-02-21T11:44:43.737Z","good":true,"top":false,"reply_count":29,"visit_count":133987,"create_at":"2013-08-08T14:11:36.535Z","author":{"loginname":"ggaaooppeenngg","avatar_url":"https://avatars.githubusercontent.com/u/4769989?v=3&s=120"}}]
     */

    private boolean success;
    private List<DataBean> data;

    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    public List<DataBean> getData() {
        return data;
    }

    public void setData(List<DataBean> data) {
        this.data = data;
    }

    public static class DataBean {
        /**
         * id : 5c81f8e65b8cb21491ca732b
         * author_id : 5c1af54c3898674067a76341
         * tab : job
         * content : <div class="markdown-text"><h2>招聘岗位</h2>
         <p><a href="https://www.lagou.com/jobs/5545546.html">Node.js 后台工程师</a> 1-3年 12-23K</p>
         <p><a href="http://https://www.lagou.com/jobs/5545547.html">高级 Node.js 后台工程师</a> 3-5年 25-35K</p>
         <p><a href="https://www.lagou.com/jobs/5545556.html">Node.js 后台开发经理</a>  5-10年 30-50K</p>
         <p><a href="https://www.lagou.com/jobs/5545581.html">Node.js 全栈工程师</a> 1-3年 12-23K</p>
         <p><a href="https://www.lagou.com/jobs/5545582.html">高级 Node.js 全栈工程师</a> 3-5年 25-40K</p>
         <h2>福利待遇</h2>
         <p>1、当月工资当月发放，2-6 个月的工资作为年终奖
         2、全额工资购买六险一金
         3、带薪病假、带薪年假（入职即可享有 5 天带薪年假）
         4、入职提供最新型号之 Apple 15 ” MacBook Pro, LG 真 4K 显示器
         5、办公室零食不间断、每天下午茶
         6、关注员工成长，购买书籍、在线课程均可报销（不限类别）
         7、每年定期体检及其他健康检查
         8、每年不定期外出旅游
         9、任意挑选使用各种付费工具，如 JetBrains IDE, Newrelic, Pingdom, 你想得出，只要可以帮助工作做好，公司绝对愿意支持!</p>
         <h2>关于 AfterShip</h2>
         <p>网址：<a href="https://www.aftership.com/">https://www.aftership.com/</a></p>
         <p>2012 年成立于香港，2014 年开始盈利，专注于 SaaS 平台企业服务，业务遍布全球，与全球 470 多家物流公司达成合作，涉及 30 多种主流语言业务体系；帮助跨境电商及平台，将全球快递信息查询自动化，优化发货流程，提高退货效率，减低营运成本，提高买家复购率，让企业专注于品牌建设。</p>
         <p>AfterShip 是一家以产品为驱动，技术为核心的公司，日均承担过亿 API 请求。从公司成立开始，便大量使用优秀开源系统，拥抱创新科技，公司有良好的 SaaS 付费习惯，与 Google，Amazon 等公司均有密切的业务来往。</p>
         <p>戳这里看看 Google 给我们的介绍 <a href="https://cloud.google.com/customers/aftership/">https://cloud.google.com/customers/aftership/</a></p>
         <h2>客户案例</h2>
         <p>AfterShip 是快递查询行业的全球龙头，客户有 Amazon, Wish, eBay, Paypal, Groupon, Etsy, 及各大小电商超过 100,000 家。</p>
         <h2>我们要找的人</h2>
         <p>我们是一群热爱编程的代码农,但我们不是代码奴！</p>
         <p>我们为写的代码负责，对代码质素有要求，由代码风格开始，测试，编写技术文档，一丝不苟。 我们注重自动化，使用自动化测试，持续集成与持续交付提升生产力。</p>
         <p>我们使用 New Relic 作系统监测、Pingdom, Pagerduty 报警、Cloudflare CDN 加速、Twilio 发 SMS、Sendgrid 发邮件、1Password 管理密码、Zoom 视象会议、还有很多很多的工具。</p>
         <p>我们为 AfterShip 公司自豪，是因为 AfterShip 对员工的重视，人才永远放在第一，为员工负责， 不断推动我们学习，提升技能。
         我们大量使用开源软件,因为我们深信分享是最伟大的。 我们願意贡献我们有用的,把好的东西跟全世界分享。
         我们使用的 SaaS 工具: <a href="https://github.com/AfterShip/SaaS">https://github.com/AfterShip/SaaS</a>
         我们的代码风格: <a href="https://github.com/AfterShip/eslint-config-aftership">https://github.com/AfterShip/eslint-config-aftership</a>
         自动格式化全球电话号码: <a href="https://github.com/AfterShip/phone">https://github.com/AfterShip/phone</a>
         Koa middleware for New Relic: <a href="https://github.com/AfterShip/koa-newrelic">https://github.com/AfterShip/koa-newrelic</a></p>
         <p>如果你的想法跟我们一样,欢迎加入我们这支精小而灵活的公司!</p>
         <h2>联系方式</h2>
         <p>HR 直招，近期和年后看工作的都可以跟我联系哦
         业务增长迅速，持续有需求，欢迎推荐和自荐（推荐他人成功入职，有奖励 1-2W ）
         邮箱： <a href="mailto:xhzeng@aftership.com">xhzeng@aftership.com</a>
         微信：z492521906 （备注 cnode、个人姓名、意向岗位）</p>
         </div>
         * title : 深圳南山#AfterShip 招聘 Node.js，有高级和leader岗，每天过亿API请求，国际性SaaS平台，全球性项目，福利待遇好
         * last_reply_at : 2019-03-14T00:20:03.449Z
         * good : true
         * top : false
         * reply_count : 4
         * visit_count : 459
         * create_at : 2019-03-08T05:08:54.556Z
         * author : {"loginname":"littleflowersansan","avatar_url":"https://avatars3.githubusercontent.com/u/42596541?v=4&s=120"}
         */

        private String id;
        private String author_id;
        private String tab;
        private String content;
        private String title;
        private String last_reply_at;
        private boolean good;
        private boolean top;
        private int reply_count;
        private int visit_count;
        private String create_at;
        private AuthorBean author;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getAuthor_id() {
            return author_id;
        }

        public void setAuthor_id(String author_id) {
            this.author_id = author_id;
        }

        public String getTab() {
            return tab;
        }

        public void setTab(String tab) {
            this.tab = tab;
        }

        public String getContent() {
            return content;
        }

        public void setContent(String content) {
            this.content = content;
        }

        public String getTitle() {
            return title;
        }

        public void setTitle(String title) {
            this.title = title;
        }

        public String getLast_reply_at() {
            return last_reply_at;
        }

        public void setLast_reply_at(String last_reply_at) {
            this.last_reply_at = last_reply_at;
        }

        public boolean isGood() {
            return good;
        }

        public void setGood(boolean good) {
            this.good = good;
        }

        public boolean isTop() {
            return top;
        }

        public void setTop(boolean top) {
            this.top = top;
        }

        public int getReply_count() {
            return reply_count;
        }

        public void setReply_count(int reply_count) {
            this.reply_count = reply_count;
        }

        public int getVisit_count() {
            return visit_count;
        }

        public void setVisit_count(int visit_count) {
            this.visit_count = visit_count;
        }

        public String getCreate_at() {
            return create_at;
        }

        public void setCreate_at(String create_at) {
            this.create_at = create_at;
        }

        public AuthorBean getAuthor() {
            return author;
        }

        public void setAuthor(AuthorBean author) {
            this.author = author;
        }

        public static class AuthorBean {
            /**
             * loginname : littleflowersansan
             * avatar_url : https://avatars3.githubusercontent.com/u/42596541?v=4&s=120
             */

            private String loginname;
            private String avatar_url;

            public String getLoginname() {
                return loginname;
            }

            public void setLoginname(String loginname) {
                this.loginname = loginname;
            }

            public String getAvatar_url() {
                return avatar_url;
            }

            public void setAvatar_url(String avatar_url) {
                this.avatar_url = avatar_url;
            }
        }
    }
}
